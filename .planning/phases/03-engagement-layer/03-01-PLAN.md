---
phase: 03-engagement-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260301000005_engagement_layer.sql
  - src/features/notifications/hooks.ts
  - src/features/notifications/types.ts
  - app/_layout.tsx
  - supabase/functions/push-notify/index.ts
  - supabase/functions/process-reminders/index.ts
autonomous: true
requirements:
  - NOTF-01
  - NOTF-02
  - NOTF-03

must_haves:
  truths:
    - "User receives a push notification when a group member adds an expense to a shared group"
    - "User receives a push notification when a group member records a settlement with them"
    - "Notification tap navigates the user to the relevant expense or settlement screen"
    - "User can enable/disable smart reminders and set delay_days per group"
    - "Smart reminders are dispatched daily by a pg_cron job for unpaid debts older than delay_days"
  artifacts:
    - path: "supabase/migrations/20260301000005_engagement_layer.sql"
      provides: "fx_rates table, reminder_config table, pg_cron jobs for fx-rates and reminders"
    - path: "src/features/notifications/hooks.ts"
      provides: "usePushTokenRegistration, useNotificationDeepLink, useReminderConfig hooks"
    - path: "src/features/notifications/types.ts"
      provides: "ReminderConfig, PushPayload type definitions"
    - path: "app/_layout.tsx"
      provides: "push token registration and deep-link handler wired at app launch"
    - path: "supabase/functions/push-notify/index.ts"
      provides: "DB webhook handler — expenses/settlements INSERT → Expo Push API"
    - path: "supabase/functions/process-reminders/index.ts"
      provides: "daily pg_cron Edge Function that checks balances and dispatches reminder pushes"
  key_links:
    - from: "app/_layout.tsx"
      to: "profiles.push_token"
      via: "usePushTokenRegistration upserts token on launch"
      pattern: "profiles.*update.*push_token"
    - from: "supabase/functions/push-notify/index.ts"
      to: "exp.host/--/api/v2/push/send"
      via: "fetch with EXPO_ACCESS_TOKEN header"
      pattern: "exp\\.host.*push/send"
    - from: "supabase/functions/process-reminders/index.ts"
      to: "reminder_config"
      via: "query enabled=true configs, compute balance age, emit push"
      pattern: "reminder_config.*enabled"
---

<objective>
Build the push notification chain: DB schema for FX rates and reminder config, EAS push token lifecycle, push-notify Edge Function (expenses + settlements webhooks), deep-link navigation on notification tap, and the process-reminders Edge Function triggered daily by pg_cron for configurable smart reminders.

Purpose: Turn the app from passive (user must open) to active (app notifies users of relevant events), which is the primary retention driver for a split-expense app.
Output: DB migration with new tables + two Deno Edge Functions + notification hooks wired into root layout
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-engagement-layer/03-RESEARCH.md

# Phase 2 patterns established
@.planning/phases/02-core-expense-loop/02-03-SUMMARY.md
</context>

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/features/groups/types.ts:
```typescript
export interface Group {
  id: string
  name: string
  base_currency: string
  created_by: string | null
  is_direct: boolean
}

export interface GroupMember {
  id: string
  group_id: string
  user_id: string | null   // null = named-only member
  display_name: string
  role: 'admin' | 'member'
}
```

From app/_layout.tsx (existing module-level setup):
```typescript
// Module-level: onlineManager wired to NetInfo
// queryClient.setMutationDefaults(['expenses','create'], { mutationFn })
// Both must stay — do NOT remove or move them
```

Existing profiles schema (Phase 1):
```sql
-- profiles.push_token TEXT column already exists from Phase 1 migration
-- profiles(id) references auth.users(id)
```

supabase/functions pattern (from simplify-debts/index.ts):
```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
// Service role is OK in Edge Functions — NOT in mobile bundle
const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!)
Deno.serve(async (req) => { ... })
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: DB migration — engagement layer schema + pg_cron jobs</name>
  <files>supabase/migrations/20260301000005_engagement_layer.sql</files>
  <action>
Create migration `supabase/migrations/20260301000005_engagement_layer.sql` with:

1. **fx_rates table** (needed by Plan 03-02 multi-currency):
```sql
CREATE TABLE public.fx_rates (
  currency    TEXT PRIMARY KEY,
  rate_to_usd NUMERIC(18, 8) NOT NULL,
  fetched_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);
ALTER TABLE public.fx_rates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "anon_can_read_fx_rates" ON public.fx_rates
  FOR SELECT USING (true);
```

2. **reminder_config table** (NOTF-03):
```sql
CREATE TABLE public.reminder_config (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id    UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  group_id   UUID NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  enabled    BOOLEAN NOT NULL DEFAULT true,
  delay_days INTEGER NOT NULL DEFAULT 3 CHECK (delay_days >= 1 AND delay_days <= 30),
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  UNIQUE (user_id, group_id)
);
ALTER TABLE public.reminder_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "users_manage_own_reminder_config"
  ON public.reminder_config FOR ALL
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());
```

3. **pg_cron jobs** — wrap in a DO block that checks cron schema exists before scheduling to avoid silent failure when pg_cron is not enabled:
```sql
DO $$
BEGIN
  -- fx-rates-cache: every hour
  IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron') THEN
    PERFORM cron.schedule(
      'fx-rates-hourly',
      '0 * * * *',
      $$SELECT net.http_post(
          url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'project_url') || '/functions/v1/fx-rates-cache',
          headers := jsonb_build_object('Content-Type','application/json','Authorization','Bearer ' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'anon_key')),
          body := '{}'::jsonb) AS request_id;$$
    );
    -- process-reminders: daily at 08:00 UTC
    PERFORM cron.schedule(
      'process-reminders-daily',
      '0 8 * * *',
      $$SELECT net.http_post(
          url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'project_url') || '/functions/v1/process-reminders',
          headers := jsonb_build_object('Content-Type','application/json','Authorization','Bearer ' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'anon_key')),
          body := '{}'::jsonb) AS request_id;$$
    );
  END IF;
END $$;
```

Add a comment block at the top of the migration noting that pg_cron and pg_net must be enabled in Supabase Dashboard > Database > Extensions before the cron jobs will fire.
  </action>
  <verify>
    <automated>cat "supabase/migrations/20260301000005_engagement_layer.sql" | grep -c "CREATE TABLE" | grep -q "^2$" && echo "PASS: 2 tables created" || echo "FAIL: expected 2 tables"</automated>
  </verify>
  <done>Migration file exists with fx_rates table, reminder_config table (both with RLS), and pg_cron scheduling block</done>
</task>

<task type="auto">
  <name>Task 2: Push token registration + notification deep-link hooks</name>
  <files>src/features/notifications/types.ts, src/features/notifications/hooks.ts, app/_layout.tsx</files>
  <action>
Install new packages first:
```bash
npx expo install expo-notifications expo-device expo-sharing
```

**src/features/notifications/types.ts** — define types:
```typescript
export interface ReminderConfig {
  id: string
  user_id: string
  group_id: string
  enabled: boolean
  delay_days: number
  created_at: string
  updated_at: string
}

export interface UpsertReminderConfigInput {
  group_id: string
  enabled: boolean
  delay_days: number
}
```

**src/features/notifications/hooks.ts** — three hooks:

1. `registerPushToken(): Promise<void>` — called at app launch (not a hook, but async function):
   - Guard: `if (!Device.isDevice) return` — simulators throw on getExpoPushTokenAsync
   - Android: `await Notifications.setNotificationChannelAsync('default', { name: 'Default notifications', importance: Notifications.AndroidImportance.MAX, sound: 'default' })` — MUST be before token request
   - Request permissions: `Notifications.requestPermissionsAsync()`, early return if not granted (never block the app)
   - `const projectId = Constants.expoConfig?.extra?.eas?.projectId`
   - `const token = (await Notifications.getExpoPushTokenAsync({ projectId })).data`
   - Upsert: `await supabase.from('profiles').update({ push_token: token }).eq('id', user.id)`
   - Register `Notifications.addPushTokenListener` for mid-session token rotation — upsert again on new token

2. `useNotificationDeepLink(): void` — call in root layout:
   - `useEffect` with `Notifications.addNotificationResponseReceivedListener(response => router.push(response.notification.request.content.data?.url))`
   - Also handle cold-start: `Notifications.getLastNotificationResponse().then(r => if (r?.notification) router.push(...))`
   - Return cleanup: `sub.remove()`

3. `useReminderConfig(groupId: string)` — React Query hook:
   - Query: `supabase.from('reminder_config').select('*').eq('group_id', groupId).eq('user_id', userId).maybeSingle()`
   - Mutation `upsertReminderConfig`: INSERT ... ON CONFLICT (user_id, group_id) DO UPDATE using `.upsert({ user_id, group_id, enabled, delay_days }, { onConflict: 'user_id,group_id' })`
   - Invalidate `['reminder_config', groupId]` on success

Set the foreground notification handler at module-top of hooks.ts (outside any function):
```typescript
import * as Notifications from 'expo-notifications'
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: false,
    shouldShowBanner: true,
    shouldShowList: true,
  }),
})
```

**app/_layout.tsx** — add to the existing file WITHOUT removing existing setup (NetInfo + setMutationDefaults):
- Import `registerPushToken` and `useNotificationDeepLink` from `@/features/notifications/hooks`
- Call `registerPushToken()` inside `RootNavigator` in a `useEffect` that depends on `session` — only register when authenticated: `useEffect(() => { if (session) { registerPushToken() } }, [session])`
- Call `useNotificationDeepLink()` inside `RootNavigator` unconditionally (handles deep links regardless of auth state for cold-start)
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | grep -E "notifications/hooks|notifications/types|_layout" | head -5 || echo "PASS: no TS errors in notification files"</automated>
  </verify>
  <done>expo-notifications and expo-device installed; notification hooks file exists with all three functions; _layout.tsx calls registerPushToken on auth and useNotificationDeepLink unconditionally; TypeScript compiles without errors in these files</done>
</task>

<task type="auto">
  <name>Task 3: push-notify + process-reminders Edge Functions</name>
  <files>supabase/functions/push-notify/index.ts, supabase/functions/process-reminders/index.ts</files>
  <action>
**supabase/functions/push-notify/index.ts** — DB webhook handler for NOTF-01 and NOTF-02:

This function receives Supabase Database Webhook POSTs (payload: `{ type, table, record, old_record }`) for INSERT events on `expenses` and `settlements` tables.

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const EXPO_PUSH_URL = 'https://exp.host/--/api/v2/push/send'

Deno.serve(async (req: Request) => {
  const payload = await req.json()
  const { table, record } = payload

  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    // Service role is intentional in Edge Functions — not in mobile bundle
  )

  let recipientUserIds: string[] = []
  let title = ''
  let body = ''
  let dataUrl = ''

  if (table === 'expenses') {
    // NOTF-01: notify all group members except the expense creator
    const { data: members } = await supabase
      .from('group_members')
      .select('user_id')
      .eq('group_id', record.group_id)
      .neq('user_id', record.created_by)
      .not('user_id', 'is', null)
    recipientUserIds = (members ?? []).map((m: { user_id: string }) => m.user_id)
    title = 'New expense added'
    body = record.description ?? 'An expense was added to your group'
    dataUrl = `/groups/${record.group_id}/expenses/${record.id}`
  } else if (table === 'settlements') {
    // NOTF-02: notify the payee (the person being paid)
    const { data: payeeMember } = await supabase
      .from('group_members')
      .select('user_id')
      .eq('id', record.payee_id)
      .maybeSingle()
    if (payeeMember?.user_id) recipientUserIds = [payeeMember.user_id]
    title = 'Settlement recorded'
    body = `You received a payment in your group`
    dataUrl = `/groups/${record.group_id}/settlements`
  }

  if (recipientUserIds.length === 0) {
    return new Response(JSON.stringify({ skipped: 'no recipients' }), { status: 200 })
  }

  // Fetch push tokens — filter null tokens at DB level
  const { data: profiles } = await supabase
    .from('profiles')
    .select('id, push_token')
    .in('id', recipientUserIds)
    .not('push_token', 'is', null)

  const tokenToUserId = new Map<string, string>()
  ;(profiles ?? []).forEach((p: { id: string; push_token: string }) => {
    if (p.push_token) tokenToUserId.set(p.push_token, p.id)
  })

  if (tokenToUserId.size === 0) {
    return new Response(JSON.stringify({ skipped: 'no tokens' }), { status: 200 })
  }

  // Batch at most 100 per Expo Push API limit
  const messages = Array.from(tokenToUserId.keys()).slice(0, 100).map((to) => ({
    to, title, body, sound: 'default', data: { url: dataUrl },
  }))

  const pushRes = await fetch(EXPO_PUSH_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'Authorization': `Bearer ${Deno.env.get('EXPO_ACCESS_TOKEN') ?? ''}`,
    },
    body: JSON.stringify(messages),
  })
  const pushJson = await pushRes.json()

  // Handle DeviceNotRegistered receipts: null out stale tokens
  // tickets[i].status === 'error' && tickets[i].details?.error === 'DeviceNotRegistered'
  const tickets: Array<{ status: string; details?: { error?: string } }> = pushJson.data ?? []
  const tokenList = Array.from(tokenToUserId.keys()).slice(0, 100)
  const staleTokens = tickets
    .map((t, i) => (t.status === 'error' && t.details?.error === 'DeviceNotRegistered' ? tokenList[i] : null))
    .filter(Boolean) as string[]

  if (staleTokens.length > 0) {
    await supabase
      .from('profiles')
      .update({ push_token: null })
      .in('push_token', staleTokens)
  }

  return new Response(JSON.stringify({ sent: messages.length, stale_cleared: staleTokens.length }), { status: 200 })
})
```

**supabase/functions/process-reminders/index.ts** — daily cron job for NOTF-03:

This function is triggered by pg_cron daily at 08:00 UTC. It queries reminder_config for enabled entries, computes whether any debts for that user/group are older than delay_days, and dispatches push notifications.

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const EXPO_PUSH_URL = 'https://exp.host/--/api/v2/push/send'

Deno.serve(async (_req: Request) => {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
  )

  // Fetch all enabled reminder configs
  const { data: configs, error } = await supabase
    .from('reminder_config')
    .select('user_id, group_id, delay_days')
    .eq('enabled', true)

  if (error || !configs || configs.length === 0) {
    return new Response(JSON.stringify({ skipped: 'no active configs' }), { status: 200 })
  }

  const messages: Array<{ to: string; title: string; body: string; sound: string; data: object }> = []

  for (const config of configs) {
    // Compute net balance for this user in this group from expense_splits and settlements
    // A debt "older than delay_days" means the oldest unsettled split.created_at is at least delay_days old
    const cutoff = new Date(Date.now() - config.delay_days * 86_400_000).toISOString()

    const { data: oldSplits } = await supabase
      .from('expense_splits')
      .select('id, expense:expenses(group_id, deleted_at)')
      .eq('member_id', config.group_id)  // note: splits use member_id (group_members.id), not user_id
      .lt('created_at', cutoff)
      .limit(1)

    // Simpler approach: check if user's group_member has unpaid debts by querying balances
    // Get group_member.id for this user in this group
    const { data: member } = await supabase
      .from('group_members')
      .select('id')
      .eq('group_id', config.group_id)
      .eq('user_id', config.user_id)
      .maybeSingle()

    if (!member) continue

    // Sum splits where member owes (they are split recipient, not payer)
    const { data: splits } = await supabase
      .from('expense_splits')
      .select('amount_cents, created_at, expense:expenses(payer_id, deleted_at, group_id)')
      .eq('member_id', member.id)
      .lt('created_at', cutoff)

    const unpaidSplits = (splits ?? []).filter((s: any) =>
      s.expense?.deleted_at === null &&
      s.expense?.group_id === config.group_id &&
      s.expense?.payer_id !== member.id  // they owe (they are NOT the payer)
    )

    if (unpaidSplits.length === 0) continue

    const totalOwedCents = unpaidSplits.reduce((sum: number, s: any) => sum + s.amount_cents, 0)
    if (totalOwedCents <= 0) continue

    // Get push token for this user
    const { data: profile } = await supabase
      .from('profiles')
      .select('push_token')
      .eq('id', config.user_id)
      .maybeSingle()

    if (!profile?.push_token) continue

    messages.push({
      to: profile.push_token,
      title: 'Debt reminder',
      body: `You still owe $${(totalOwedCents / 100).toFixed(2)} in a group. Tap to settle up.`,
      sound: 'default',
      data: { url: `/groups/${config.group_id}` },
    })
  }

  if (messages.length === 0) {
    return new Response(JSON.stringify({ sent: 0 }), { status: 200 })
  }

  // Send in batches of 100
  for (let i = 0; i < messages.length; i += 100) {
    await fetch(EXPO_PUSH_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': `Bearer ${Deno.env.get('EXPO_ACCESS_TOKEN') ?? ''}`,
      },
      body: JSON.stringify(messages.slice(i, i + 100)),
    })
  }

  return new Response(JSON.stringify({ sent: messages.length }), { status: 200 })
})
```

Note: DB Webhooks for the `expenses` and `settlements` tables pointing to the `push-notify` function must be configured in Supabase Dashboard → Database → Webhooks after deployment. This is a manual dashboard step (no IaC for DB webhooks). Document this in a code comment at the top of the push-notify function.
  </action>
  <verify>
    <automated>ls supabase/functions/push-notify/index.ts supabase/functions/process-reminders/index.ts && echo "PASS: both Edge Function files exist" || echo "FAIL: missing Edge Function files"</automated>
  </verify>
  <done>Both Edge Function files exist; push-notify handles expenses/settlements webhooks with DeviceNotRegistered cleanup; process-reminders iterates reminder_config and dispatches debt nudge pushes; both use service_role key (server-only, not mobile bundle)</done>
</task>

</tasks>

<verification>
Run `npx tsc --noEmit` — no errors in the notification files.
Verify migration: `grep -c "CREATE TABLE" supabase/migrations/20260301000005_engagement_layer.sql` returns 2.
Verify Edge Functions exist: `ls supabase/functions/push-notify/index.ts supabase/functions/process-reminders/index.ts`
Verify _layout.tsx imports registerPushToken: `grep "registerPushToken" app/_layout.tsx`
</verification>

<success_criteria>
- Migration file 20260301000005_engagement_layer.sql exists with fx_rates + reminder_config tables, both with RLS
- pg_cron scheduling block present in migration (guarded by extension check)
- expo-notifications and expo-device installed (in package.json)
- src/features/notifications/hooks.ts exists with registerPushToken, useNotificationDeepLink, useReminderConfig
- app/_layout.tsx registers push token on session and handles deep-link navigation
- supabase/functions/push-notify/index.ts handles expenses + settlements INSERT webhooks with DeviceNotRegistered handling
- supabase/functions/process-reminders/index.ts processes daily reminder_config and dispatches debt nudges
- TypeScript compiles without errors in modified files
</success_criteria>

<output>
After completion, create `.planning/phases/03-engagement-layer/03-01-SUMMARY.md`
</output>
