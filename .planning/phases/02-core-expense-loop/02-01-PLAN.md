---
phase: 02-core-expense-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260228000003_expense_loop.sql
  - src/features/expenses/types.ts
  - src/features/expenses/splits.ts
  - src/features/expenses/splits.test.ts
  - src/features/expenses/categories.ts
  - src/features/expenses/hooks.ts
  - src/components/expenses/SplitEditor.tsx
  - src/components/expenses/ExpenseCard.tsx
  - src/components/ui/ExpandableFAB.tsx
  - app/(app)/expenses/new.tsx
  - app/(app)/expenses/[id]/index.tsx
  - app/(app)/expenses/[id]/edit.tsx
  - app/(app)/index.tsx
autonomous: true
requirements:
  - EXPN-01
  - EXPN-02
  - EXPN-03
  - EXPN-04
  - EXPN-05
  - EXPN-06
  - EXPN-07
  - EXPN-08
  - EXPN-09
  - UIUX-03

user_setup: []

must_haves:
  truths:
    - "User can open a new expense form from the FAB and submit an expense with amount, description, payer, date, and category"
    - "User can select equal, exact, percentage, or shares split mode and the form correctly distributes amounts across selected members"
    - "The sum of all split amounts always equals the total expense amount (no penny drift)"
    - "User can edit or delete an expense they created from the expense detail screen"
    - "User can create a 1-on-1 expense outside a group (is_direct virtual group); the virtual group does not appear in the main groups list"
    - "The FAB on the dashboard expands to show Manual Entry, Add Transfer, and Scan Receipt child buttons"
  artifacts:
    - path: "supabase/migrations/20260228000003_expense_loop.sql"
      provides: "activities, expense_comments, expense_reactions tables with RLS; is_direct column on groups"
    - path: "src/features/expenses/types.ts"
      provides: "Expense, ExpenseSplit, CreateExpenseInput, UpdateExpenseInput types"
      exports: ["Expense", "ExpenseSplit", "CreateExpenseInput", "SplitType"]
    - path: "src/features/expenses/splits.ts"
      provides: "Pure split calculation functions for all four split modes"
      exports: ["computeEqualSplits", "computeExactSplits", "computePercentageSplits", "computeSharesSplits"]
    - path: "src/features/expenses/hooks.ts"
      provides: "useExpenses, useCreateExpense, useUpdateExpense, useDeleteExpense hooks"
    - path: "app/(app)/expenses/new.tsx"
      provides: "Expense entry form screen"
    - path: "app/(app)/expenses/[id]/edit.tsx"
      provides: "Expense edit screen"
    - path: "src/components/ui/ExpandableFAB.tsx"
      provides: "Expandable FAB with three child actions"
  key_links:
    - from: "app/(app)/expenses/new.tsx"
      to: "src/features/expenses/hooks.ts useCreateExpense"
      via: "useMutation call on form submit"
      pattern: "useCreateExpense"
    - from: "src/features/expenses/hooks.ts"
      to: "supabase expenses + expense_splits tables"
      via: "two-step insert with rollback on split failure"
      pattern: "supabase.from\\('expenses'\\)"
    - from: "src/components/expenses/SplitEditor.tsx"
      to: "src/features/expenses/splits.ts"
      via: "calls compute* functions to preview split amounts live"
      pattern: "computeEqualSplits|computeExactSplits|computePercentageSplits|computeSharesSplits"
    - from: "app/(app)/index.tsx"
      to: "src/components/ui/ExpandableFAB.tsx"
      via: "FAB placed in dashboard screen"
      pattern: "ExpandableFAB"
---

<objective>
Build the complete expense entry flow: database migration for new Phase 2 tables, pure split calculation functions, React Query hooks for expense CRUD, the four-mode split editor component, expense form and edit screens, and the expandable FAB.

Purpose: The expense entry flow is the core of the app ‚Äî everything else (balances, settlement) depends on expenses existing. Plan 02-01 establishes the data model and UI entry point that plans 02-02 and 02-03 build on.
Output: Working expense creation with all four split modes, edit/delete flows, 1-on-1 support, and an expandable FAB on the dashboard.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-expense-loop/02-RESEARCH.md

<interfaces>
<!-- Existing types and patterns the executor needs. No codebase exploration required. -->

From src/features/groups/types.ts:
```typescript
export interface Group {
  id: string
  name: string
  base_currency: string
  created_by: string | null
  version: number
  created_at: string
  updated_at: string
}

export interface GroupMember {
  id: string
  group_id: string
  user_id: string | null    // null = named-only member
  display_name: string
  role: 'admin' | 'member'
  joined_at: string
  created_at: string
}
```

From src/features/groups/hooks.ts:
```typescript
export function useGroups(): UseQueryResult<Group[]>
export function useGroup(groupId: string): UseQueryResult<{ group: Group; members: GroupMember[] }>
// getCurrentUserId(): async helper ‚Äî supabase.auth.getUser().data.user.id
```

From src/lib/supabase.ts:
```typescript
export const supabase = createClient(supabaseUrl, supabaseAnonKey, { auth: { storage: localStorage, ... } })
```

From app/_layout.tsx:
```typescript
// PersistQueryClientProvider wraps entire app with persister + maxAge 24h
// onSuccess callback is available for resumePausedMutations (add in Plan 02-03)
```

Foundation migration columns on expenses table (20260227000001_foundation.sql):
```sql
CREATE TABLE public.expenses (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  group_id         UUID NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  created_by       UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  description      TEXT NOT NULL,
  amount_cents     INTEGER NOT NULL CHECK (amount_cents > 0),
  currency         TEXT NOT NULL DEFAULT 'USD',
  base_currency    TEXT NOT NULL DEFAULT 'USD',
  fx_rate_at_creation NUMERIC(18,8) NOT NULL DEFAULT 1.0,
  amount_base_cents INTEGER NOT NULL,
  split_type       TEXT NOT NULL CHECK (split_type IN ('equal','exact','percentage','shares')),
  payer_id         UUID REFERENCES public.group_members(id) ON DELETE SET NULL,
  expense_date     DATE NOT NULL DEFAULT CURRENT_DATE,
  category         TEXT,
  deleted_at       TIMESTAMPTZ,
  idempotency_key  UUID NOT NULL UNIQUE,
  version          INTEGER NOT NULL DEFAULT 1,
  created_at       TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at       TIMESTAMPTZ DEFAULT now() NOT NULL
);
-- expense_splits: id, expense_id, member_id (FK group_members.id), amount_cents, created_at
-- settlements: id, group_id, payer_id, payee_id, amount_cents, currency, note, idempotency_key, settled_at, created_at
-- groups: has is_direct BOOLEAN after migration 003 (add via ALTER TABLE in new migration)
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: DB migration + expense types + pure split functions</name>
  <files>
    supabase/migrations/20260228000003_expense_loop.sql,
    src/features/expenses/types.ts,
    src/features/expenses/splits.ts,
    src/features/expenses/categories.ts
  </files>
  <behavior>
    - computeEqualSplits(1000, ['a','b','c']) ‚Üí [{member_id:'a',amount_cents:334},{member_id:'b',amount_cents:333},{member_id:'c',amount_cents:333}]
    - computeEqualSplits(100, ['a','b']) ‚Üí [{amount_cents:50},{amount_cents:50}] (no remainder)
    - computeSharesSplits(1000, [{member_id:'a',shares:1},{member_id:'b',shares:2}]) ‚Üí [{amount_cents:333},{amount_cents:667}] (total = 1000)
    - computePercentageSplits(1000, [{member_id:'a',percentage:33},{member_id:'b',percentage:67}]) ‚Üí [{amount_cents:330},{amount_cents:670}]
    - computeExactSplits validates sum equals totalCents and throws if not
    - All functions: splits.reduce((s,m) => s + m.amount_cents, 0) === totalCents invariant always holds
  </behavior>
  <action>
1. Write migration `supabase/migrations/20260228000003_expense_loop.sql`. Include:
   - `ALTER TABLE public.groups ADD COLUMN is_direct BOOLEAN NOT NULL DEFAULT false;` (EXPN-09 virtual group flag)
   - CREATE TABLE `public.activities` (id UUID PK, group_id UUID FK groups ON DELETE CASCADE, actor_id UUID FK profiles ON DELETE SET NULL, action_type TEXT CHECK IN ('expense_added','expense_edited','expense_deleted','settlement_recorded','comment_added','reaction_added'), expense_id UUID FK expenses ON DELETE SET NULL, metadata JSONB, created_at TIMESTAMPTZ DEFAULT now()). ENABLE RLS. Policies: SELECT where group_id IN (user's group_member rows); INSERT same check.
   - CREATE TABLE `public.expense_comments` (id UUID PK, expense_id UUID FK expenses ON DELETE CASCADE, author_id UUID FK profiles ON DELETE CASCADE, body TEXT CHECK char_length 1..1000, created_at TIMESTAMPTZ). ENABLE RLS. SELECT policy: expense's group_id in user's groups. INSERT policy: author_id = auth.uid() AND expense's group accessible.
   - CREATE TABLE `public.expense_reactions` (id UUID PK, expense_id UUID FK expenses ON DELETE CASCADE, user_id UUID FK profiles ON DELETE CASCADE, emoji TEXT CHECK char_length <= 8, created_at TIMESTAMPTZ, UNIQUE(expense_id, user_id)). ENABLE RLS. SELECT/INSERT same as comments. DELETE policy: user_id = auth.uid().
   - Indexes: idx_activities_group_id, idx_activities_created_at DESC, idx_expense_comments_expense_id, idx_expense_reactions_expense_id.
   - Migration comment at top: `-- Phase 2: activities, expense_comments, expense_reactions tables; is_direct column on groups`
   - SECURITY NOTE: Follow foundation pattern ‚Äî ENABLE ROW LEVEL SECURITY immediately after each CREATE TABLE before any other statement.

2. Create `src/features/expenses/types.ts`:
```typescript
export type SplitType = 'equal' | 'exact' | 'percentage' | 'shares'

export interface Expense {
  id: string
  group_id: string
  created_by: string | null
  description: string
  amount_cents: number
  currency: string
  base_currency: string
  fx_rate_at_creation: number
  amount_base_cents: number
  split_type: SplitType
  payer_id: string | null
  expense_date: string       // ISO date string YYYY-MM-DD
  category: string | null
  deleted_at: string | null
  idempotency_key: string
  version: number
  created_at: string
  updated_at: string
}

export interface ExpenseSplit {
  id: string
  expense_id: string
  member_id: string
  amount_cents: number
  created_at: string
}

export interface SplitInput {
  member_id: string
  amount_cents?: number   // exact mode
  percentage?: number     // percentage mode
  shares?: number         // shares mode
}

export interface CreateExpenseInput {
  group_id: string
  description: string
  amount_cents: number
  currency?: string
  split_type: SplitType
  payer_member_id: string
  expense_date: string
  category?: string
  splits: Array<{ member_id: string; amount_cents: number }>
  idempotency_key: string  // UUID generated client-side with crypto.randomUUID()
}

export interface UpdateExpenseInput {
  id: string
  group_id: string
  description?: string
  amount_cents?: number
  split_type?: SplitType
  payer_member_id?: string
  expense_date?: string
  category?: string
  splits?: Array<{ member_id: string; amount_cents: number }>
}
```

3. Create `src/features/expenses/splits.ts`. Implement four pure functions with zero external dependencies:
   - `computeEqualSplits(totalCents, memberIds)`: base = floor(total/n), remainder = total - base*n, first `remainder` members get base+1. Assert sum === totalCents before returning.
   - `computeExactSplits(totalCents, memberAmounts)`: validates sum equals totalCents, throws Error('Exact splits do not sum to total') if not. Returns the input amounts directly as the result array.
   - `computePercentageSplits(totalCents, memberPercentages)`: delegates to `computeSharesSplits` using percentage values as share weights. Validates percentages sum to 100 (¬±0.01 tolerance), throws if not.
   - `computeSharesSplits(totalCents, memberShares)`: for i < last: amount = floor(shares/totalShares * totalCents), track assigned; last member = totalCents - assigned. Assert sum === totalCents.
   - All functions return `Array<{ member_id: string; amount_cents: number }>`.

4. Create `src/features/expenses/splits.test.ts` BEFORE implementing splits.ts (TDD). Write Jest test cases directly from the `<behavior>` block above:
```typescript
import { computeEqualSplits, computeExactSplits, computePercentageSplits, computeSharesSplits } from './splits'

describe('computeEqualSplits', () => {
  it('distributes remainder to first members', () => {
    const result = computeEqualSplits(1000, ['a', 'b', 'c'])
    expect(result).toEqual([
      { member_id: 'a', amount_cents: 334 },
      { member_id: 'b', amount_cents: 333 },
      { member_id: 'c', amount_cents: 333 },
    ])
  })
  it('splits evenly with no remainder', () => {
    const result = computeEqualSplits(100, ['a', 'b'])
    expect(result.every(r => r.amount_cents === 50)).toBe(true)
  })
  it('always sums to totalCents', () => {
    const result = computeEqualSplits(997, ['a', 'b', 'c', 'd'])
    expect(result.reduce((s, r) => s + r.amount_cents, 0)).toBe(997)
  })
})

describe('computeSharesSplits', () => {
  it('allocates proportionally and sums exactly', () => {
    const result = computeSharesSplits(1000, [{ member_id: 'a', shares: 1 }, { member_id: 'b', shares: 2 }])
    expect(result.reduce((s, r) => s + r.amount_cents, 0)).toBe(1000)
    expect(result[1].amount_cents).toBe(667)
  })
})

describe('computePercentageSplits', () => {
  it('converts percentages to cent amounts summing to total', () => {
    const result = computePercentageSplits(1000, [{ member_id: 'a', percentage: 33 }, { member_id: 'b', percentage: 67 }])
    expect(result.reduce((s, r) => s + r.amount_cents, 0)).toBe(1000)
  })
  it('throws when percentages do not sum to 100', () => {
    expect(() => computePercentageSplits(1000, [{ member_id: 'a', percentage: 50 }])).toThrow()
  })
})

describe('computeExactSplits', () => {
  it('throws when amounts do not sum to total', () => {
    expect(() => computeExactSplits(1000, [{ member_id: 'a', amount_cents: 600 }, { member_id: 'b', amount_cents: 300 }])).toThrow('Exact splits do not sum to total')
  })
  it('returns inputs directly when sum matches', () => {
    const inputs = [{ member_id: 'a', amount_cents: 400 }, { member_id: 'b', amount_cents: 600 }]
    expect(computeExactSplits(1000, inputs)).toEqual(inputs)
  })
})
```
Write the test file first, confirm it fails (red), then implement splits.ts to make it pass (green).

5. Create `src/features/expenses/categories.ts`. Export a static `CATEGORIES` array:
```typescript
export const CATEGORIES = [
  { id: 'food', label: 'Food & Drink', icon: 'üçΩÔ∏è' },
  { id: 'transport', label: 'Transport', icon: 'üöó' },
  { id: 'accommodation', label: 'Accommodation', icon: 'üè†' },
  { id: 'shopping', label: 'Shopping', icon: 'üõçÔ∏è' },
  { id: 'entertainment', label: 'Entertainment', icon: 'üé≠' },
  { id: 'health', label: 'Health', icon: 'üè•' },
  { id: 'utilities', label: 'Utilities', icon: 'üí°' },
  { id: 'travel', label: 'Travel', icon: '‚úàÔ∏è' },
  { id: 'other', label: 'Other', icon: 'üì¶' },
] as const
export type CategoryId = typeof CATEGORIES[number]['id']
```
  </action>
  <verify>
    <automated>cd "/c/Aman/Coding-Bamzii/Web Development/Owe" && npx jest --testPathPattern="expenses/splits" 2>&1 | tail -10</automated>
  </verify>
  <done>
    - Migration file exists with all 3 new tables + is_direct column, each with ENABLE ROW LEVEL SECURITY before any other statement
    - types.ts exports Expense, ExpenseSplit, CreateExpenseInput, SplitType
    - splits.ts exports all four compute functions; sum invariant holds for all four modes
    - categories.ts exports CATEGORIES constant with 9 entries
    - splits.test.ts exists and was written before splits.ts (TDD order)
    - `npx jest --testPathPattern="expenses/splits"` exits 0 with all tests passing
  </done>
</task>

<task type="auto">
  <name>Task 2: Expense hooks + SplitEditor + expense screens + ExpandableFAB</name>
  <files>
    src/features/expenses/hooks.ts,
    src/components/expenses/SplitEditor.tsx,
    src/components/expenses/ExpenseCard.tsx,
    src/components/ui/ExpandableFAB.tsx,
    app/(app)/expenses/new.tsx,
    app/(app)/expenses/[id]/index.tsx,
    app/(app)/expenses/[id]/edit.tsx,
    app/(app)/index.tsx
  </files>
  <action>
1. Create `src/features/expenses/hooks.ts`:

**useExpenses(groupId):** queryKey `['expenses', groupId]`, fetches expenses WHERE group_id = groupId AND deleted_at IS NULL ordered by expense_date DESC. staleTime 30_000.

**useCreateExpense():** mutationKey `['expenses', 'create']` (REQUIRED for OFFL-02 ‚Äî plan 02-03 wires the resume). Two-step insert: (a) INSERT into expenses, (b) INSERT all splits into expense_splits. On split failure: immediately DELETE the orphaned expense row, then throw. Use `crypto.randomUUID()` for idempotency_key generation if not provided. On success: invalidate `['expenses', groupId]` and `['balances']`.

**useUpdateExpense():** mutationKey `['expenses', 'update']`. UPDATE expenses SET (description, amount_cents, split_type, payer_id, expense_date, category, version = version+1). Then DELETE all existing expense_splits for this expense_id, then INSERT new splits. On success: invalidate same query keys as create.

**useDeleteExpense():** mutationKey `['expenses', 'delete']`. Soft-delete: UPDATE expenses SET deleted_at = now() WHERE id = $1 AND created_by = auth.uid(). On success: invalidate.

**useExpense(expenseId):** queryKey `['expenses', 'detail', expenseId]`, fetches single expense with its splits via `.select('*, expense_splits(*)')`.

All hooks: use `import { supabase } from '@/lib/supabase'` and `import { useQueryClient, useMutation, useQuery } from '@tanstack/react-query'`.

2. Create `src/components/expenses/SplitEditor.tsx`. Props: `members: GroupMember[]`, `totalCents: number`, `splitType: SplitType`, `onSplitTypeChange: (type: SplitType) => void`, `onSplitsChange: (splits: SplitInput[]) => void`. Renders:
   - Four tab buttons: Equal | Exact | Percentage | Shares. Active tab uses `bg-brand-primary`, inactive `bg-dark-surface`.
   - For Equal mode: shows computed amounts per member (read-only). Calls `computeEqualSplits` on every totalCents or member change and calls `onSplitsChange`.
   - For Exact mode: shows a TextInput per member for cents entry. Displays running total vs target. Validation border turns `border-red-500` when sum ‚â† totalCents.
   - For Percentage mode: TextInput per member for percentage (0-100). Sum indicator shows current total. Calls `computePercentageSplits` when sum = 100.
   - For Shares mode: integer stepper (+/-) per member. Calls `computeSharesSplits` reactively.
   - All modes: member display_name shown next to input. Amount preview in formatted cents (e.g., "$10.00") shown as gray caption below each input.
   - Use `className` for all styling (NativeWind). Colors: `bg-dark-bg`, `text-white`, `text-white/50`, `border-dark-border`, `bg-brand-primary`.

3. Create `src/components/expenses/ExpenseCard.tsx`. Props: `expense: Expense`, `members: GroupMember[]`. Shows: description (white bold), amount formatted as dollars (e.g., "$12.50"), payer display_name ("paid by X"), expense_date (formatted), category emoji + label if set. Wrapped in `ReanimatedSwipeable` from `react-native-gesture-handler/ReanimatedSwipeable`. Right action (right swipe) = green "Settle" button. Left action = brand accent "Remind" button. Both actions call `swipeRef.current?.close()` first. onPress navigates to `/(app)/expenses/${expense.id}`. Use `overshootFriction={8}` on swipeable.

4. Create `src/components/ui/ExpandableFAB.tsx`. Uses `useSharedValue(0)` as open flag. `toggle()` calls `withSpring(isOpen.value === 0 ? 1 : 0)`. Three child buttons: "Manual Entry" (navigates to `/(app)/expenses/new`), "Add Transfer" (alert 'Coming soon'), "Scan Receipt" (alert 'Coming in v2'). Each child uses `useAnimatedStyle` with opacity = isOpen.value and translateY interpolating from 0 to -80/-160/-240. Main FAB: 56x56 rounded-full bg-brand-primary, "+" icon text-2xl text-white. Position: absolute bottom-8 right-6 with elevation 8. On child press: close FAB (set isOpen to 0 via withSpring) then navigate.

5. Create `app/(app)/expenses/new.tsx`. Uses `react-hook-form` Controller with zod schema:
```
z.object({
  description: z.string().min(1).max(200),
  amount: z.string().regex(/^\d+(\.\d{1,2})?$/, 'Enter a valid amount'),
  payer_member_id: z.string().uuid(),
  expense_date: z.string(),
  category: z.string().optional(),
  group_id: z.string().uuid().optional(),  // optional ‚Äî absent means direct/1-on-1 mode
})
```
Route params: `group_id` from `useLocalSearchParams()`.

**Normal group mode (group_id present):** Load group members via `useGroup(group_id)`. Payer picker: modal FlatList of group members. Category picker: horizontal ScrollView of CATEGORIES chips. SplitEditor mounted below the form fields. On valid submit: convert amount string to cents (`Math.round(parseFloat(amount) * 100)`), generate idempotency_key via `crypto.randomUUID()`, call `useCreateExpense().mutate(...)`, navigate back on success.

**Direct expense mode (no group_id ‚Äî EXPN-09):** Show a "Direct expense" header instead of a group name. Implement the full flow as follows:

5a. Add a `friendName` text field at the top of the form (TextInput, placeholder "Friend's name or @username"). This is a free-text field ‚Äî no contact lookup needed. Validation: required, min 1 char.

5b. On submit, before calling `useCreateExpense`, run `createDirectExpenseGroup(currentUserId, friendName)` ‚Äî implement this as a local async helper in new.tsx:
```typescript
async function createDirectExpenseGroup(currentUserId: string, friendName: string) {
  // Step 1: Create the virtual group
  const { data: group, error: groupErr } = await supabase
    .from('groups')
    .insert({ name: `${friendName} & me`, is_direct: true, base_currency: 'USD', created_by: currentUserId })
    .select('id')
    .single()
  if (groupErr) throw groupErr

  // Step 2: Insert current user as group member (role: admin)
  const { data: myProfile } = await supabase
    .from('profiles')
    .select('display_name')
    .eq('id', currentUserId)
    .single()
  const { data: myMember, error: myErr } = await supabase
    .from('group_members')
    .insert({ group_id: group.id, user_id: currentUserId, display_name: myProfile?.display_name ?? 'Me', role: 'admin' })
    .select('id')
    .single()
  if (myErr) throw myErr

  // Step 3: Insert friend as named-only member (user_id: null)
  const { data: friendMember, error: friendErr } = await supabase
    .from('group_members')
    .insert({ group_id: group.id, user_id: null, display_name: friendName, role: 'member' })
    .select('id')
    .single()
  if (friendErr) throw friendErr

  return { group_id: group.id, myMemberId: myMember.id, friendMemberId: friendMember.id }
}
```

5c. After `createDirectExpenseGroup` resolves, use the returned `group_id` and member IDs to construct the `CreateExpenseInput` (payer = myMemberId, splits across both members) and call `useCreateExpense().mutate(...)` as normal.

5d. On success: invalidate `['groups']` (so the new virtual group exists in cache but will be filtered from the main list by the `is_direct` filter in step 8) and navigate back.

6. Create `app/(app)/expenses/[id]/index.tsx`. Uses `useLocalSearchParams()` for id. Loads expense via `useExpense(id)`. Shows all expense fields. Edit button (top-right) navigates to `/(app)/expenses/${id}/edit`. Delete button (red, bottom) calls `useDeleteExpense` then `router.back()`. Confirms delete with `Alert.alert('Delete expense?', ..., [{text:'Cancel'},{text:'Delete',style:'destructive'}])`.

7. Create `app/(app)/expenses/[id]/edit.tsx`. Pre-populates form from existing expense data. Uses `useUpdateExpense()` on submit. Same layout as new.tsx but title "Edit expense" and submit button "Save changes".

8. Update `app/(app)/index.tsx`. Add: import and render `<ExpandableFAB />` replacing the existing simple FAB. Filter groups to exclude `is_direct = true` groups (update useGroups query OR add filter here: `groups.filter(g => !g.is_direct)`). Group type needs `is_direct?: boolean` ‚Äî update `src/features/groups/types.ts` to add `is_direct: boolean` field to the `Group` interface.
  </action>
  <verify>
    <automated>cd "/c/Aman/Coding-Bamzii/Web Development/Owe" && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - TypeScript compiles with no errors across all new files
    - useCreateExpense has mutationKey: ['expenses', 'create'] (required for Plan 02-03 offline queue)
    - Split insert failure triggers orphaned expense cleanup before throwing
    - ExpandableFAB renders on dashboard, replaces existing FAB
    - Groups list filters out is_direct groups
    - Expense form accessible via FAB "Manual Entry" with group_id param
    - Edit and delete actions work from expense detail screen
    - All NativeWind className usage follows existing dark mode conventions (bg-dark-bg, text-white, bg-brand-primary)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with 0 errors
2. `npx jest --testPathPattern="splits"` passes (split calculation invariants verified)
3. Navigation: Dashboard FAB expands ‚Üí Manual Entry ‚Üí expense form renders ‚Üí submit creates expense ‚Üí appears in group screen
4. All four split modes compute correct amounts (penny remainder absorbed by first member in equal mode)
5. Soft-delete: deleted expense has deleted_at set; does not appear in useExpenses results (query filters deleted_at IS NULL)
6. New migration file exists at supabase/migrations/20260228000003_expense_loop.sql with three new tables each having ENABLE ROW LEVEL SECURITY immediately after CREATE TABLE
</verification>

<success_criteria>
- User can add an expense from the expanded FAB using any of four split modes
- Split amounts always sum to the total expense amount exactly
- User can edit or delete their own expense
- 1-on-1 expenses create an is_direct virtual group; this group is hidden from the main groups list
- FAB expands to Manual Entry / Add Transfer / Scan Receipt with animated child buttons
- TypeScript compiles clean; no float arithmetic used for money calculations
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-expense-loop/02-01-SUMMARY.md` following the template at `.claude/get-shit-done/templates/summary.md`.
</output>
