---
phase: 02-core-expense-loop
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/features/balances/types.ts
  - src/features/balances/hooks.ts
  - src/components/balances/BalanceCard.tsx
  - supabase/functions/simplify-debts/index.ts
  - app/(app)/index.tsx
  - app/(app)/groups/[id]/index.tsx
  - app/(app)/groups/[id]/balances.tsx
autonomous: true
requirements:
  - BALS-01
  - BALS-02
  - BALS-03

user_setup: []

must_haves:
  truths:
    - "User sees a 'You owe' and 'You are owed' summary on the dashboard after expenses exist"
    - "User can open a group and see each member's net balance (positive = owed to them, negative = owes)"
    - "User can tap 'Simplified debts' in a group to see the minimum set of payments that would clear all debts"
    - "Balance totals update in real time when another group member adds an expense (Supabase Realtime)"
    - "Simplified debts are computed server-side by the Edge Function using anon key + user JWT (not service_role)"
  artifacts:
    - path: "src/features/balances/types.ts"
      provides: "BalanceSummary, MemberBalance, DebtSuggestion types"
      exports: ["BalanceSummary", "MemberBalance", "DebtSuggestion"]
    - path: "src/features/balances/hooks.ts"
      provides: "useBalanceSummary, useGroupBalances, useSimplifiedDebts, useRealtimeExpenseSync hooks"
    - path: "supabase/functions/simplify-debts/index.ts"
      provides: "Deno Edge Function implementing greedy debt simplification"
    - path: "app/(app)/groups/[id]/balances.tsx"
      provides: "Simplified debts screen for a group"
    - path: "app/(app)/index.tsx"
      provides: "Dashboard with BALS-01 summary totals (updated from Plan 02-01 base)"
  key_links:
    - from: "src/features/balances/hooks.ts useSimplifiedDebts"
      to: "supabase/functions/simplify-debts/index.ts"
      via: "supabase.functions.invoke('simplify-debts', { body: { group_id } })"
      pattern: "functions.invoke\\('simplify-debts'"
    - from: "src/features/balances/hooks.ts useGroupBalances"
      to: "expense_splits + settlements tables"
      via: "two-query client-side net balance reduction"
      pattern: "expense_splits.*expenses.*payer_id"
    - from: "src/features/balances/hooks.ts useRealtimeExpenseSync"
      to: "React Query invalidateQueries"
      via: "Supabase postgres_changes channel subscription with cleanup"
      pattern: "supabase.removeChannel"
    - from: "app/(app)/index.tsx"
      to: "src/features/balances/hooks.ts useBalanceSummary"
      via: "dashboard summary bar component"
      pattern: "useBalanceSummary"
---

<objective>
Build the balance layer: dashboard totals (BALS-01), per-group member balance breakdown (BALS-02), and the debt-simplify Supabase Edge Function with greedy algorithm (BALS-03). Wire Supabase Realtime to invalidate balances when expenses change.

Purpose: Balances are the app's core value — showing "who owes what" is why users open the app. This plan delivers the read-side of Phase 2: real-time, accurate debt visibility.
Output: Dashboard balance summary, group balances screen, simplified debts screen, Realtime sync, and the deployed Edge Function.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-expense-loop/02-RESEARCH.md
@.planning/phases/02-core-expense-loop/02-01-SUMMARY.md

<interfaces>
<!-- Types and patterns from Plan 02-01 output and existing codebase. -->

From src/features/expenses/types.ts (created in 02-01):
```typescript
export interface Expense { id, group_id, created_by, payer_id, amount_cents, split_type, deleted_at, ... }
export interface ExpenseSplit { id, expense_id, member_id, amount_cents, created_at }
```

From src/features/groups/types.ts:
```typescript
export interface GroupMember { id, group_id, user_id, display_name, role, ... }
```

From src/lib/supabase.ts:
```typescript
export const supabase // createClient with anon key + user JWT storage
```

Balance computation logic (from research — Pattern in Edge Function, replicate on client for BALS-02):
```typescript
// Net balance per member_id:
// For each split: payer gets +amount_cents, split member gets -amount_cents
// For each settlement: payer gets +amount_cents, payee gets -amount_cents
// Positive result = member is owed money; Negative = member owes money
const balances = new Map<string, number>()
for (const split of splits) {
  balances.set(split.expense.payer_id, (balances.get(split.expense.payer_id) ?? 0) + split.amount_cents)
  balances.set(split.member_id, (balances.get(split.member_id) ?? 0) - split.amount_cents)
}
for (const s of settlements) {
  balances.set(s.payer_id, (balances.get(s.payer_id) ?? 0) + s.amount_cents)
  balances.set(s.payee_id, (balances.get(s.payee_id) ?? 0) - s.amount_cents)
}
```

Realtime cleanup pattern (anti-pattern: missing cleanup):
```typescript
useEffect(() => {
  const channel = supabase.channel(`expenses:${groupId}`)
    .on('postgres_changes', { event: '*', schema: 'public', table: 'expenses', filter: `group_id=eq.${groupId}` }, () => {
      qc.invalidateQueries({ queryKey: ['expenses', groupId] })
      qc.invalidateQueries({ queryKey: ['balances', groupId] })
    })
    .subscribe()
  return () => { supabase.removeChannel(channel) }  // CRITICAL: prevents channel accumulation
}, [groupId, qc])
```

Edge Function invocation (anon key + JWT — NOT service_role):
```typescript
const { data, error } = await supabase.functions.invoke('simplify-debts', {
  body: { group_id: groupId },
})
// supabase client already has user JWT from auth session — forwarded automatically
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Balance types + hooks + Realtime + Edge Function</name>
  <files>
    src/features/balances/types.ts,
    src/features/balances/hooks.ts,
    supabase/functions/simplify-debts/index.ts
  </files>
  <action>
1. Create `src/features/balances/types.ts`:
```typescript
export interface MemberBalance {
  member_id: string
  display_name: string
  net_cents: number   // positive = owed to them; negative = they owe
}

export interface BalanceSummary {
  total_owed_cents: number      // sum of all positive net positions for current user (across all groups)
  total_owing_cents: number     // sum of all negative net positions (absolute value)
}

export interface DebtSuggestion {
  from_member_id: string
  from_display_name: string
  to_member_id: string
  to_display_name: string
  amount_cents: number
}
```

2. Create `src/features/balances/hooks.ts` with four hooks:

**useGroupBalances(groupId: string):** queryKey `['balances', groupId]`, staleTime 30_000. Fetches:
```typescript
// Step 1: expense_splits with payer info
const { data: splits } = await supabase
  .from('expense_splits')
  .select('member_id, amount_cents, expense:expenses!inner(payer_id, group_id, deleted_at)')
  .eq('expense.group_id', groupId)
  .is('expense.deleted_at', null)

// Step 2: settlements
const { data: settlements } = await supabase
  .from('settlements')
  .select('payer_id, payee_id, amount_cents')
  .eq('group_id', groupId)
```
Apply net balance reduction (Map<string, number>) as shown in the interface block above. Fetch member display_names from the group_members table for the group to map member_id → display_name. Return `MemberBalance[]` sorted by net_cents descending.

**useBalanceSummary():** queryKey `['balances', 'summary']`, staleTime 30_000. Gets current user's user_id from auth. Fetches all group_members rows for this user to get their member_ids across groups. For each group the user is in, fetches splits where member_id matches the user's member_id for that group. Computes: total_owed_cents = sum of positive net positions (other members owe the current user), total_owing_cents = absolute value of sum of negative positions. Returns `BalanceSummary`.

**useSimplifiedDebts(groupId: string):** queryKey `['simplifiedDebts', groupId]`, staleTime 60_000. Calls `supabase.functions.invoke('simplify-debts', { body: { group_id: groupId } })`. Maps returned suggestions to `DebtSuggestion[]` by looking up display_names from cached group members. Returns `DebtSuggestion[]`.

**useRealtimeExpenseSync(groupId: string):** Not a query — a hook with `useEffect`. Creates channel `expenses:${groupId}`, subscribes to postgres_changes on `expenses` table with `filter: group_id=eq.${groupId}`. On any event: invalidate `['expenses', groupId]` and `['balances', groupId]`. CRITICAL: return cleanup `() => { supabase.removeChannel(channel) }` to prevent memory leak / channel accumulation (Pitfall 4 from research).

3. Create `supabase/functions/simplify-debts/index.ts`. Implement the greedy debt simplification Edge Function exactly as shown in the research Pattern 4:
   - Import `createClient` from `https://esm.sh/@supabase/supabase-js@2`
   - Use `Deno.serve(async (req) => { ... })`
   - Parse `{ group_id }` from `await req.json()`
   - Get auth header and create supabase client with ANON_KEY + auth header forwarded (not SERVICE_ROLE — RLS must apply)
   - Fetch splits with inner join to expenses filtering group_id and deleted_at IS NULL
   - Fetch settlements for group_id
   - Build net balance Map using the same logic as useGroupBalances
   - Run greedy algorithm: separate into creditors (net > 0) and debtors (net < 0 → store as positive amount). While both arrays non-empty: sort both descending, take largest pair, emit payment suggestion for min(creditor, debtor) amount, reduce both by payment, remove zeros.
   - Return `new Response(JSON.stringify({ suggestions }), { headers: { 'Content-Type': 'application/json' } })`
   - Handle errors: wrap in try/catch, return status 500 with `{ error: error.message }` on failure
  </action>
  <verify>
    <automated>cd "/c/Aman/Coding-Bamzii/Web Development/Owe" && npx tsc --noEmit 2>&1 | grep -E "balances|simplify" | head -20</automated>
  </verify>
  <done>
    - types.ts exports MemberBalance, BalanceSummary, DebtSuggestion
    - hooks.ts exports all four hooks; useRealtimeExpenseSync has return cleanup function
    - Edge Function uses anon key + forwarded JWT (no service_role string anywhere in the function)
    - Net balance sign convention: payer gains positive, split member loses (matches research algorithm exactly)
    - TypeScript clean for balances feature files
  </done>
</task>

<task type="auto">
  <name>Task 2: Balance UI — dashboard summary, group balances screen, simplified debts screen</name>
  <files>
    src/components/balances/BalanceCard.tsx,
    app/(app)/index.tsx,
    app/(app)/groups/[id]/index.tsx,
    app/(app)/groups/[id]/balances.tsx
  </files>
  <action>
1. Create `src/components/balances/BalanceCard.tsx`. Props: `balance: MemberBalance`. Renders a row with member display_name (left, white), and net amount on the right. If net_cents > 0: show "owes you $X.XX" in green (`text-brand-success` or `text-green-400`). If net_cents < 0: show "you owe $X.XX" in red (`text-red-400`). If net_cents === 0: show "settled" in muted white/50. Format cents to dollars: `(Math.abs(net_cents) / 100).toFixed(2)`. Card style: `bg-dark-surface border border-dark-border rounded-xl px-4 py-3 mb-2`.

2. Update `app/(app)/index.tsx`. Add balance summary bar above the groups list:
   - Import and call `useBalanceSummary()`.
   - If isLoading: show small ActivityIndicator.
   - If data: render a horizontal row with two stat blocks:
     - Left: "You are owed" label (text-white/50, text-xs uppercase) + `$${(total_owed_cents/100).toFixed(2)}` (text-green-400, text-xl font-bold)
     - Right: "You owe" label + `$${(total_owing_cents/100).toFixed(2)}` (text-red-400, text-xl font-bold)
   - Container: `bg-dark-surface border border-dark-border rounded-2xl px-4 py-3 mx-4 mb-4`
   - Place this summary block in the `ListHeaderComponent` before "Your groups" label.
   - ExpandableFAB from Plan 02-01 remains in place.

3. Update `app/(app)/groups/[id]/index.tsx`. Extend the existing group detail screen to show expense list and member balances:
   - Import `useExpenses` from expenses hooks and `useGroupBalances`, `useRealtimeExpenseSync` from balances hooks.
   - Call `useRealtimeExpenseSync(groupId)` at the top of the component (no render output, just side-effect subscription).
   - Add a "Balances" section below the member list: render `<BalanceCard />` for each MemberBalance from `useGroupBalances(groupId)`.
   - Add a "Simplified Debts" button (outlined, brand-primary border) that navigates to `/(app)/groups/${groupId}/balances`.
   - Add an "Expenses" section (below Balances): render FlatList of `<ExpenseCard />` from `src/components/expenses/ExpenseCard.tsx` using `useExpenses(groupId)` data.
   - If expenses list is empty: show "No expenses yet" placeholder.

4. Create `app/(app)/groups/[id]/balances.tsx`. Simplified debts screen:
   - Get groupId from `useLocalSearchParams()`.
   - Call `useSimplifiedDebts(groupId)`.
   - Stack.Screen title: "Simplified Debts".
   - Show description text: "Minimum payments to clear all debts in this group" (text-white/50, text-sm).
   - FlatList of debt suggestions. Each row: `{from_display_name} pays {to_display_name} ${amount_cents/100 toFixed 2}`. Style: white text on dark-surface card with brand-primary "Settle" button on the right that navigates to settlement creation (settlement flow built in Plan 02-03 — button can be a placeholder for now: `router.push({ pathname: '/(app)/settlement/new', params: { payer_id: s.from_member_id, payee_id: s.to_member_id, amount_cents: s.amount_cents, group_id: groupId } })`).
   - If isLoading: ActivityIndicator. If no suggestions: "All debts are settled!" with a checkmark emoji.
  </action>
  <verify>
    <automated>cd "/c/Aman/Coding-Bamzii/Web Development/Owe" && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - Dashboard shows "You are owed" and "You owe" totals from useBalanceSummary
    - Group detail screen shows per-member net balances via BalanceCard components
    - Group detail screen subscribes to Realtime (useRealtimeExpenseSync called)
    - Simplified debts screen accessible via "Simplified Debts" button in group detail
    - Simplified debts screen calls Edge Function via useSimplifiedDebts
    - TypeScript compiles clean; no service_role key in any client-side file
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with 0 errors
2. Dashboard renders balance summary bar (zero state: $0.00 / $0.00 before any expenses)
3. After adding a test expense, group detail shows non-zero member balances
4. Simplified debts screen navigable from group detail
5. Realtime: open app in two simulators; adding expense in one updates balances in the other within ~2 seconds
6. Edge Function exists at `supabase/functions/simplify-debts/index.ts` — no `SERVICE_ROLE` or `service_role` string in the file
</verification>

<success_criteria>
- Dashboard shows accurate total balance summary for current user
- Per-group member balances display with correct sign (positive = owed, negative = owing)
- Simplified debts screen shows server-computed minimum payment suggestions
- Balances update in real-time via Supabase Realtime subscription
- Realtime subscription is cleaned up on screen unmount (no channel accumulation)
- No float arithmetic used anywhere in balance computation
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-expense-loop/02-02-SUMMARY.md` following the template at `.claude/get-shit-done/templates/summary.md`.
</output>
