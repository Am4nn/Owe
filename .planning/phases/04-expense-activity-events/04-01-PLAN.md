---
phase: 04-expense-activity-events
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/features/expenses/hooks.ts
autonomous: true
requirements:
  - ACTY-01
  - ACTY-02

must_haves:
  truths:
    - Adding an expense in a group produces an activity row with action_type 'expense_added' that appears in the activity feed
    - Editing an expense produces an activity row with action_type 'expense_edited' that appears in the activity feed
    - Deleting an expense produces an activity row with action_type 'expense_deleted' that appears in the activity feed
    - All activity rows have actor_id referencing group_members(id) — not profiles(id) — with a valid group_id, so group-scoped feed filtering returns them
    - The activity feed invalidates automatically after create/edit/delete so the feed screen refreshes without a manual reload
  artifacts:
    - src/features/expenses/hooks.ts (modified — createExpenseMutationFn, useUpdateExpense, useDeleteExpense each insert into activities)
  key_links:
    - createExpenseMutationFn → activities INSERT must be inside the function body (not onSuccess) — offline-resumed mutations only re-run mutationFn
    - actor_id must be actorMember.id from group_members, NOT the auth user UUID — FK references group_members(id) since migration 20260301000004
    - onSuccess in useCreateExpense, useUpdateExpense, useDeleteExpense must invalidate ['activity', group_id] and ['activity', 'all']
---

<objective>
Wire the three expense CUD mutation functions in `src/features/expenses/hooks.ts` to write activity rows into the `activities` table after each successful database operation.

Purpose: The activity feed (useActivityFeed) already queries the activities table, but it shows no expense events because createExpenseMutationFn, useUpdateExpense, and useDeleteExpense never insert into it. This closes the ACTY-01 FAIL gate from the v1.0 audit. ACTY-02 (group-scoped filter) is automatically satisfied because every inserted activity row carries group_id.

Output: One modified file — src/features/expenses/hooks.ts — with three new activity INSERT blocks and updated onSuccess cache invalidation.
</objective>

<execution_context>
@C:/Users/125ar/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/125ar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@src/features/expenses/hooks.ts
@src/features/settlements/hooks.ts

<interfaces>
<!-- Key types and patterns the executor needs. Extracted from codebase. No exploration required. -->

From src/features/expenses/hooks.ts (current state — sole file to edit):

```typescript
// Line 6-10: getCurrentUserId helper (returns string only — do NOT use for actor resolution, use supabase.auth.getUser() directly)
async function getCurrentUserId(): Promise<string> {
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')
  return user.id
}

// Line 57-114: createExpenseMutationFn — standalone named export required for OFFL-02 offline queue.
// Step 1 (lines 75-94): INSERT into expenses. Step 2 (lines 96-111): INSERT into expense_splits.
// Line 90: created_by: await getCurrentUserId()  ← REPLACE with getUser() to avoid double round-trip
// Line 113: return expense as Expense  ← activity INSERT goes BEFORE this return

// Line 122-132: useCreateExpense — onSuccess invalidates ['expenses', input.group_id] and ['balances']
// Add ['activity', input.group_id] and ['activity', 'all'] to this onSuccess.

// Line 138-190: useUpdateExpense — mutationFn destructures: { id, description, amount_cents, split_type,
//   payer_member_id, expense_date, category, splits } from input: UpdateExpenseInput
//   UpdateExpenseInput includes group_id (verified from src/features/expenses/types.ts line 56)
// Line 182: return updatedExpense as Expense  ← activity INSERT goes BEFORE this return
// onSuccess (lines 184-188): invalidates expenses + balances. Add activity keys.

// Line 196-216: useDeleteExpense — mutationFn receives { id, group_id }: { id: string; group_id: string }
// Line 201: const userId = await getCurrentUserId()  ← reuse this for actor lookup
// Line 208: return { id, group_id }  ← activity INSERT goes BEFORE this return
// onSuccess (lines 210-214): invalidates expenses + balances. Add activity keys.
```

From src/features/settlements/hooks.ts (reference pattern — copy verbatim):

```typescript
// Lines 41-63: Exact actor resolution + activity INSERT pattern to replicate:

// Step 2: Resolve actor_id (current user's member_id in this group)
const { data: { user } } = await supabase.auth.getUser()
if (!user) throw new Error('Not authenticated')

const { data: actorMember, error: actorError } = await supabase
  .from('group_members')
  .select('id')
  .eq('group_id', group_id)
  .eq('user_id', user.id)
  .single()
if (actorError) throw actorError

// Step 3: Insert activity row
const { error: activityError } = await supabase
  .from('activities')
  .insert({
    action_type: 'settlement_recorded', // ← swap action_type per mutation
    group_id,
    actor_id: actorMember.id,
    expense_id: null,                   // ← use expense.id for expense events
    metadata: { amount_cents },         // ← see payload spec below
  })
if (activityError) throw activityError
```

From src/features/activity/hooks.ts (query key for cache invalidation):

```typescript
// Line 19: queryKey: ['activity', groupId ?? 'all']
// → invalidate ['activity', group_id] AND ['activity', 'all'] in every onSuccess
```

Activities table CHECK constraint (from migration 20260228000003_expense_loop.sql):

```sql
action_type TEXT NOT NULL CHECK (action_type IN (
  'expense_added', 'expense_edited', 'expense_deleted',
  'settlement_recorded', 'comment_added', 'reaction_added'
))
-- All three expense action_types are pre-authorized. No migration needed.
```

actor_id FK (from migration 20260301000004_fix_activities_actor_fk.sql):

```sql
FOREIGN KEY (actor_id) REFERENCES public.group_members(id) ON DELETE SET NULL
-- actor_id MUST be group_members.id (actorMember.id), NOT the auth user UUID
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add activity INSERT to createExpenseMutationFn</name>
  <files>src/features/expenses/hooks.ts</files>
  <action>
Modify `createExpenseMutationFn` (lines 57-114) to insert an `expense_added` activity row after the splits INSERT succeeds.

**Change 1 — Consolidate getUser() call (eliminate double round-trip):**

At line 90, replace:
```typescript
created_by: await getCurrentUserId(),
```
with:
```typescript
created_by: user.id,
```

To make `user` available, add a `supabase.auth.getUser()` call at the very top of the function body — BEFORE Step 1 — replacing the inline `getCurrentUserId()` usage:

```typescript
export async function createExpenseMutationFn(input: CreateExpenseInput): Promise<Expense> {
  const {
    group_id,
    description,
    // ... (all existing destructuring unchanged)
  } = input

  // Resolve authenticated user once — reused for created_by and actor resolution
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  // Step 1: Insert the expense  (unchanged except created_by: user.id)
  const { data: expense, error: expenseError } = await supabase
    .from('expenses')
    .insert({
      // ... all fields unchanged ...
      created_by: user.id,   // ← was: await getCurrentUserId()
    })
    ...
```

**Change 2 — Add Steps 3 and 4 after the splits INSERT succeeds (after line 111 `if (splitsError) {...}` block), before `return expense as Expense`:**

```typescript
  // Step 3: Resolve actor_id (current user's member_id in this group)
  const { data: actorMember, error: actorError } = await supabase
    .from('group_members')
    .select('id')
    .eq('group_id', group_id)
    .eq('user_id', user.id)
    .single()
  if (actorError) throw actorError

  // Step 4: Insert activity row
  const { error: activityError } = await supabase
    .from('activities')
    .insert({
      action_type: 'expense_added',
      group_id,
      actor_id: actorMember.id,
      expense_id: expense.id,
      metadata: { description },
    })
  if (activityError) throw activityError

  return expense as Expense
```

**CRITICAL — do NOT place the activity INSERT in onSuccess of useCreateExpense.** The offline mutation queue (OFFL-02) re-runs `mutationFn` on reconnect but does not fire `onSuccess`. The INSERT must be inside the standalone function body.

**Change 3 — Update onSuccess in useCreateExpense (lines 127-130) to also invalidate activity queries:**

```typescript
onSuccess: (_data, input) => {
  qc.invalidateQueries({ queryKey: ['expenses', input.group_id] })
  qc.invalidateQueries({ queryKey: ['balances'] })
  qc.invalidateQueries({ queryKey: ['activity', input.group_id] })  // add
  qc.invalidateQueries({ queryKey: ['activity', 'all'] })            // add
},
```
  </action>
  <verify>
    <automated>npx jest src/features/expenses/splits.test.ts --passWithNoTests</automated>
  </verify>
  <done>
    - createExpenseMutationFn performs a single supabase.auth.getUser() call (not two)
    - After splits INSERT, actor lookup and activities INSERT execute before return
    - useCreateExpense.onSuccess invalidates ['activity', input.group_id] and ['activity', 'all']
    - npx jest passes (existing split math tests unaffected)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add activity INSERT to useUpdateExpense and useDeleteExpense</name>
  <files>src/features/expenses/hooks.ts</files>
  <action>
Modify `useUpdateExpense` and `useDeleteExpense` inline mutationFn closures to insert activity rows and update onSuccess cache invalidation.

**useUpdateExpense changes:**

The mutationFn currently ends at line 182: `return updatedExpense as Expense`. The function has access to `input` which contains both `input.id` (expense id) and `input.group_id` (verified from UpdateExpenseInput in types.ts line 56).

After the splits replacement block (after the closing `}` of `if (splits && splits.length > 0) {...}` at line 180), insert before `return updatedExpense as Expense`:

```typescript
      // Resolve actor_id and insert expense_edited activity row
      const { data: { user: actorUser } } = await supabase.auth.getUser()
      if (!actorUser) throw new Error('Not authenticated')

      const { data: actorMember, error: actorError } = await supabase
        .from('group_members')
        .select('id')
        .eq('group_id', input.group_id)
        .eq('user_id', actorUser.id)
        .single()
      if (actorError) throw actorError

      const { error: activityError } = await supabase
        .from('activities')
        .insert({
          action_type: 'expense_edited',
          group_id: input.group_id,
          actor_id: actorMember.id,
          expense_id: input.id,
          metadata: null,
        })
      if (activityError) throw activityError

      return updatedExpense as Expense
```

Update onSuccess (currently lines 184-188) to also invalidate activity queries:

```typescript
    onSuccess: (_data, input) => {
      qc.invalidateQueries({ queryKey: ['expenses', input.group_id] })
      qc.invalidateQueries({ queryKey: ['expenses', 'detail', input.id] })
      qc.invalidateQueries({ queryKey: ['balances'] })
      qc.invalidateQueries({ queryKey: ['activity', input.group_id] })  // add
      qc.invalidateQueries({ queryKey: ['activity', 'all'] })            // add
    },
```

**useDeleteExpense changes:**

The mutationFn receives `{ id, group_id }` and already has `userId` from `getCurrentUserId()` at line 201. After the soft-delete `if (error) throw error` at line 207, insert before `return { id, group_id }`:

```typescript
      // Resolve actor_id (reuse userId already fetched above)
      const { data: actorMember, error: actorError } = await supabase
        .from('group_members')
        .select('id')
        .eq('group_id', group_id)
        .eq('user_id', userId)
        .single()
      if (actorError) throw actorError

      const { error: activityError } = await supabase
        .from('activities')
        .insert({
          action_type: 'expense_deleted',
          group_id,
          actor_id: actorMember.id,
          expense_id: id,
          metadata: null,
        })
      if (activityError) throw activityError

      return { id, group_id }
```

Update onSuccess (currently lines 210-214) to also invalidate activity queries:

```typescript
    onSuccess: (_data, input) => {
      qc.invalidateQueries({ queryKey: ['expenses', input.group_id] })
      qc.invalidateQueries({ queryKey: ['expenses', 'detail', input.id] })
      qc.invalidateQueries({ queryKey: ['balances'] })
      qc.invalidateQueries({ queryKey: ['activity', input.group_id] })  // add
      qc.invalidateQueries({ queryKey: ['activity', 'all'] })            // add
    },
```

**Important note for useDeleteExpense:** `userId` is a `string` (from `getCurrentUserId()`) — it is the auth user's UUID. The `.eq('user_id', userId)` lookup on group_members is correct because `group_members.user_id` stores the auth UUID. `actorMember.id` (the result) is the `group_members.id` UUID, which is what `activities.actor_id` expects.
  </action>
  <verify>
    <automated>npx jest src/features/expenses/splits.test.ts --passWithNoTests</automated>
  </verify>
  <done>
    - useUpdateExpense.mutationFn resolves actor via group_members and inserts expense_edited row before returning
    - useUpdateExpense.onSuccess invalidates ['activity', input.group_id] and ['activity', 'all']
    - useDeleteExpense.mutationFn reuses existing userId, resolves actor via group_members, inserts expense_deleted row before returning
    - useDeleteExpense.onSuccess invalidates ['activity', input.group_id] and ['activity', 'all']
    - npx jest passes
    - TypeScript compiles without errors: npx tsc --noEmit exits 0
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full file is coherent:

1. **TypeScript check:** `npx tsc --noEmit` — must exit 0 with no errors
2. **Tests:** `npx jest src/features/expenses/splits.test.ts --passWithNoTests` — must pass
3. **Structural check:** Each of the three mutation functions (createExpenseMutationFn, useUpdateExpense mutationFn, useDeleteExpense mutationFn) contains:
   - A `group_members` SELECT with `.eq('group_id', ...)` and `.eq('user_id', ...)`
   - An `activities` INSERT with the correct `action_type` string
   - `if (actorError) throw actorError` and `if (activityError) throw activityError`
4. **onSuccess check:** All three hooks (useCreateExpense, useUpdateExpense, useDeleteExpense) have both `['activity', ...]` invalidations in their onSuccess handlers
5. **No duplicate getUser() in createExpenseMutationFn:** The function must call `supabase.auth.getUser()` exactly once (at the top), and `user.id` is reused for both `created_by` and the group_members lookup
</verification>

<success_criteria>
Phase 4 is complete when:
1. Adding an expense in a group produces an activity row with action_type 'expense_added' visible in the activity feed (ACTY-01 satisfied)
2. Editing an expense produces an activity row with action_type 'expense_edited' in the activity feed
3. Deleting an expense produces an activity row with action_type 'expense_deleted' in the activity feed
4. All activity rows have a valid actor_id (group_members.id) and group_id so group-scoped filtering works correctly (ACTY-02 satisfied)
5. `npx tsc --noEmit` exits 0
6. `npx jest` passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-expense-activity-events/04-01-SUMMARY.md` using the standard summary template at @C:/Users/125ar/.claude/get-shit-done/templates/summary.md
</output>
