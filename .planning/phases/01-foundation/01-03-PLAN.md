---
phase: 01-foundation
plan: "03"
type: execute
wave: 2
depends_on:
  - "01-01"
  - "01-02"
files_modified:
  - app/_layout.tsx
  - app/(auth)/_layout.tsx
  - app/(auth)/sign-in.tsx
  - app/(auth)/sign-up.tsx
  - app/(app)/_layout.tsx
  - app/(app)/index.tsx
  - app/(app)/profile.tsx
  - app/(app)/groups/index.tsx
  - app/(app)/groups/new.tsx
  - app/(app)/groups/[id]/index.tsx
  - src/features/auth/hooks.ts
  - src/features/auth/types.ts
  - src/features/groups/hooks.ts
  - src/features/groups/types.ts
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04
  - AUTH-05
  - GRUP-01
  - GRUP-02
  - GRUP-03
  - GRUP-04
  - GRUP-05
  - OFFL-01

must_haves:
  truths:
    - "User can sign up with email + password and see their profile screen immediately after"
    - "User can sign in with email + password and land on the dashboard"
    - "User session persists across full app restarts (kill + reopen) without re-authenticating"
    - "Sign out button on profile screen clears session and redirects to sign-in — works from any screen"
    - "User can set a display name and avatar photo on the profile screen"
    - "User can create a named group — they are automatically added as admin"
    - "User can add a named-only (non-app) member when creating or editing a group"
    - "Groups list on the dashboard shows all groups the user belongs to"
    - "User can leave a group via the group detail screen"
    - "Groups list remains visible with no connectivity (OFFL-01 — MMKV cache shows stale data)"
  artifacts:
    - path: "src/features/auth/hooks.ts"
      provides: "useSession, useSignIn, useSignUp, useSignOut, useProfile, useUpdateProfile"
      exports: ["useSession", "useSignIn", "useSignUp", "useSignOut", "useProfile", "useUpdateProfile"]
    - path: "src/features/auth/types.ts"
      provides: "Profile, SignInInput, SignUpInput TypeScript types"
      exports: ["Profile", "SignInInput", "SignUpInput"]
    - path: "src/features/groups/hooks.ts"
      provides: "useGroups, useCreateGroup, useGroup, useLeaveGroup, useAddNamedMember, useInviteMember"
      exports: ["useGroups", "useCreateGroup", "useGroup", "useLeaveGroup", "useAddNamedMember", "useInviteMember"]
    - path: "src/features/groups/types.ts"
      provides: "Group, GroupMember, CreateGroupInput, AddNamedMemberInput TypeScript types"
      exports: ["Group", "GroupMember", "CreateGroupInput", "AddNamedMemberInput"]
    - path: "app/(app)/_layout.tsx"
      provides: "Auth-gated layout using Stack.Protected"
      contains: "Stack.Protected"
    - path: "app/(app)/groups/index.tsx"
      provides: "Groups list screen consuming useGroups hook"
      contains: "useGroups"
  key_links:
    - from: "app/_layout.tsx"
      to: "src/features/auth/hooks.ts"
      via: "useSession hook drives Stack.Protected guard"
      pattern: "useSession"
    - from: "app/(app)/groups/index.tsx"
      to: "src/features/groups/hooks.ts"
      via: "useGroups query — data persists offline via MMKV"
      pattern: "useGroups"
    - from: "src/features/auth/hooks.ts"
      to: "src/lib/supabase.ts"
      via: "supabase.auth.signInWithPassword, onAuthStateChange"
      pattern: "supabase\\.auth\\."
    - from: "src/features/groups/hooks.ts"
      to: "src/lib/supabase.ts"
      via: "supabase.from('group_members').select"
      pattern: "supabase\\.from\\('group_members'\\)"
---

<objective>
Implement the full auth and groups feature set: sign up, sign in, sign out, session persistence, profile creation with avatar upload, group CRUD (create, list, member management including named-only non-app members, leave), and the offline read cache that makes groups visible with no connectivity. This is where the database schema from Plan 01-02 and the project scaffold from Plan 01-01 become a working app.

Purpose: Deliver the twelve Phase 1 requirements (AUTH-01 through AUTH-05, GRUP-01 through GRUP-05, OFFL-01) as real user-facing screens. The offline cache (OFFL-01) works automatically via the MMKV persister wired in Plan 01-01 — the `useGroups` hook just needs `staleTime` and `gcTime` set correctly.

Output: A working authenticated app with sign-up/in/out flows, profile management, and group CRUD — all backed by Supabase with RLS enforced at the database level.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md

<!-- Key interfaces from Plan 01-01 that this plan builds on -->
<interfaces>
<!-- From src/lib/supabase.ts (created in Plan 01-01): -->
import { supabase } from '@/lib/supabase'
// supabase is a SupabaseClient with auth.storage = expo-sqlite localStorage

<!-- From src/lib/queryClient.ts (created in Plan 01-01): -->
import { queryClient } from '@/lib/queryClient'
// queryClient has gcTime: 86400000 (24h) and staleTime: 30000 (30s)

<!-- From src/components/ui (created in Plan 01-01): -->
import { Button } from '@/components/ui/Button'
import { Input } from '@/components/ui/Input'
// Button props: title, variant ('primary'|'secondary'|'danger'), standard TouchableOpacity props
// Input props: label?, error?, standard TextInput props

<!-- From app/_layout.tsx (created in Plan 01-01 — update it in this plan): -->
// Current: basic PersistQueryClientProvider wrapper with Stack
// Update to: add session-based Stack.Protected routing

<!-- Database schema (from Plan 01-02): -->
-- public.profiles: id UUID, display_name TEXT, avatar_url TEXT, push_token TEXT
-- public.groups: id UUID, name TEXT, base_currency TEXT, created_by UUID, version INTEGER
-- public.group_members: id UUID, group_id UUID, user_id UUID (nullable), display_name TEXT, role TEXT
-- public.group_invites: id UUID, group_id UUID, invited_email TEXT, invited_by UUID, expires_at TIMESTAMPTZ
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auth feature hooks, types, and app/_layout.tsx auth routing</name>
  <files>
    src/features/auth/types.ts
    src/features/auth/hooks.ts
    app/_layout.tsx
    app/(auth)/sign-in.tsx
    app/(auth)/sign-up.tsx
    app/(app)/_layout.tsx
    app/(app)/profile.tsx
  </files>
  <action>
Create the auth feature slice and update the root layout with session-based routing. All Supabase calls live in hooks — screens never import supabase directly.

**src/features/auth/types.ts**:
```typescript
export interface Profile {
  id: string
  display_name: string | null
  avatar_url: string | null
  push_token: string | null
  created_at: string
  updated_at: string
}

export interface SignInInput {
  email: string
  password: string
}

export interface SignUpInput {
  email: string
  password: string
  displayName: string
}

export interface UpdateProfileInput {
  display_name?: string
  avatar_url?: string
}
```

**src/features/auth/hooks.ts** — Session management, sign in/up/out, profile CRUD:
```typescript
import { useState, useEffect } from 'react'
import { Session } from '@supabase/supabase-js'
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { queryClient as globalQueryClient } from '@/lib/queryClient'
import type { Profile, SignInInput, SignUpInput, UpdateProfileInput } from './types'

// AUTH-03: Session persistence — reads from expo-sqlite localStorage on mount
export function useSession() {
  const [session, setSession] = useState<Session | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    // Load the persisted session from expo-sqlite localStorage
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session)
      setIsLoading(false)
    })

    // Subscribe to auth state changes (sign in, sign out, token refresh)
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session)
        setIsLoading(false)
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  return { session, isLoading }
}

// AUTH-01: Sign up with email + password + display name
export function useSignUp() {
  return useMutation({
    mutationFn: async ({ email, password, displayName }: SignUpInput) => {
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: { display_name: displayName }, // Passed to handle_new_user trigger
        },
      })
      if (error) throw error
      return data
    },
  })
}

// AUTH-02: Sign in with email + password
export function useSignIn() {
  return useMutation({
    mutationFn: async ({ email, password }: SignInInput) => {
      const { data, error } = await supabase.auth.signInWithPassword({ email, password })
      if (error) throw error
      return data
    },
  })
}

// AUTH-04: Sign out — clears session AND React Query cache (prevents stale data leakage)
export function useSignOut() {
  return useMutation({
    mutationFn: async () => {
      const { error } = await supabase.auth.signOut()
      if (error) throw error
    },
    onSuccess: () => {
      // Clear ALL cached server state when user signs out
      // This prevents stale data from one user leaking to the next session
      globalQueryClient.clear()
    },
  })
}

// AUTH-05: Read the current user's profile
export function useProfile() {
  return useQuery({
    queryKey: ['profile'],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('Not authenticated')
      const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', user.id)
        .single()
      if (error) throw error
      return data as Profile
    },
    staleTime: 60_000, // Profile data is stable — refresh every minute
  })
}

// AUTH-05: Update display name and/or avatar
export function useUpdateProfile() {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: async (input: UpdateProfileInput) => {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('Not authenticated')
      const { data, error } = await supabase
        .from('profiles')
        .update({ ...input, updated_at: new Date().toISOString() })
        .eq('id', user.id)
        .select()
        .single()
      if (error) throw error
      return data as Profile
    },
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: ['profile'] })
    },
  })
}
```

**app/_layout.tsx** — Update to include session-based routing (replaces the placeholder from Plan 01-01):
```tsx
import { Stack } from 'expo-router'
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import { ActivityIndicator, View } from 'react-native'
import { queryClient } from '@/lib/queryClient'
import { persister } from '@/lib/persister'
import { useSession } from '@/features/auth/hooks'
import '@/stores/ui'

function RootNavigator() {
  const { session, isLoading } = useSession()

  if (isLoading) {
    return (
      <View className="flex-1 bg-dark-bg items-center justify-center">
        <ActivityIndicator color="#6C63FF" />
      </View>
    )
  }

  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* Unauthenticated route group — only accessible when NOT signed in */}
      <Stack.Protected guard={!session}>
        <Stack.Screen name="(auth)" />
      </Stack.Protected>

      {/* Protected route group — only accessible when signed in */}
      <Stack.Protected guard={!!session}>
        <Stack.Screen name="(app)" />
      </Stack.Protected>
    </Stack>
  )
}

export default function RootLayout() {
  return (
    <PersistQueryClientProvider
      client={queryClient}
      persistOptions={{
        persister,
        maxAge: 1000 * 60 * 60 * 24, // 24 hours
      }}
    >
      <RootNavigator />
    </PersistQueryClientProvider>
  )
}
```

**app/(auth)/sign-up.tsx** — Full sign-up screen with form validation:
```tsx
import { View, Text, ScrollView, Alert } from 'react-native'
import { useForm, Controller } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { Link, router } from 'expo-router'
import { Button } from '@/components/ui/Button'
import { Input } from '@/components/ui/Input'
import { useSignUp } from '@/features/auth/hooks'

const signUpSchema = z.object({
  displayName: z.string().min(2, 'Name must be at least 2 characters').max(50),
  email: z.string().email('Please enter a valid email'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
})

type SignUpForm = z.infer<typeof signUpSchema>

export default function SignUpScreen() {
  const { mutate: signUp, isPending } = useSignUp()
  const { control, handleSubmit, formState: { errors } } = useForm<SignUpForm>({
    resolver: zodResolver(signUpSchema),
  })

  const onSubmit = (data: SignUpForm) => {
    signUp(data, {
      onSuccess: () => {
        // Auth state change triggers navigation automatically via Stack.Protected
      },
      onError: (error) => {
        Alert.alert('Sign Up Failed', error.message)
      },
    })
  }

  return (
    <ScrollView
      className="flex-1 bg-dark-bg"
      contentContainerClassName="px-6 py-12"
      keyboardShouldPersistTaps="handled"
    >
      <Text className="text-white text-3xl font-bold mb-2">Create account</Text>
      <Text className="text-white/50 text-base mb-8">Split expenses, settle up fair.</Text>

      <View className="gap-4">
        <Controller
          control={control}
          name="displayName"
          render={({ field: { onChange, value } }) => (
            <Input
              label="Your name"
              placeholder="How should we call you?"
              value={value}
              onChangeText={onChange}
              error={errors.displayName?.message}
            />
          )}
        />
        <Controller
          control={control}
          name="email"
          render={({ field: { onChange, value } }) => (
            <Input
              label="Email"
              placeholder="you@example.com"
              keyboardType="email-address"
              autoCapitalize="none"
              value={value}
              onChangeText={onChange}
              error={errors.email?.message}
            />
          )}
        />
        <Controller
          control={control}
          name="password"
          render={({ field: { onChange, value } }) => (
            <Input
              label="Password"
              placeholder="8+ characters"
              secureTextEntry
              value={value}
              onChangeText={onChange}
              error={errors.password?.message}
            />
          )}
        />
      </View>

      <Button
        title={isPending ? 'Creating account...' : 'Create account'}
        onPress={handleSubmit(onSubmit)}
        disabled={isPending}
        className="mt-8"
      />

      <View className="flex-row justify-center mt-6">
        <Text className="text-white/50">Already have an account? </Text>
        <Link href="/(auth)/sign-in">
          <Text className="text-brand-primary font-semibold">Sign in</Text>
        </Link>
      </View>
    </ScrollView>
  )
}
```

**app/(auth)/sign-in.tsx** — Full sign-in screen with form validation:
```tsx
import { View, Text, ScrollView, Alert } from 'react-native'
import { useForm, Controller } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { Link } from 'expo-router'
import { Button } from '@/components/ui/Button'
import { Input } from '@/components/ui/Input'
import { useSignIn } from '@/features/auth/hooks'

const signInSchema = z.object({
  email: z.string().email('Please enter a valid email'),
  password: z.string().min(1, 'Password is required'),
})

type SignInForm = z.infer<typeof signInSchema>

export default function SignInScreen() {
  const { mutate: signIn, isPending } = useSignIn()
  const { control, handleSubmit, formState: { errors } } = useForm<SignInForm>({
    resolver: zodResolver(signInSchema),
  })

  const onSubmit = (data: SignInForm) => {
    signIn(data, {
      onError: (error) => {
        Alert.alert('Sign In Failed', error.message)
      },
    })
  }

  return (
    <ScrollView
      className="flex-1 bg-dark-bg"
      contentContainerClassName="px-6 py-12"
      keyboardShouldPersistTaps="handled"
    >
      <Text className="text-brand-primary text-4xl font-bold mb-2">Nexus</Text>
      <Text className="text-white text-2xl font-bold mb-1">Welcome back</Text>
      <Text className="text-white/50 text-base mb-8">Sign in to continue</Text>

      <View className="gap-4">
        <Controller
          control={control}
          name="email"
          render={({ field: { onChange, value } }) => (
            <Input
              label="Email"
              placeholder="you@example.com"
              keyboardType="email-address"
              autoCapitalize="none"
              value={value}
              onChangeText={onChange}
              error={errors.email?.message}
            />
          )}
        />
        <Controller
          control={control}
          name="password"
          render={({ field: { onChange, value } }) => (
            <Input
              label="Password"
              placeholder="Your password"
              secureTextEntry
              value={value}
              onChangeText={onChange}
              error={errors.password?.message}
            />
          )}
        />
      </View>

      <Button
        title={isPending ? 'Signing in...' : 'Sign in'}
        onPress={handleSubmit(onSubmit)}
        disabled={isPending}
        className="mt-8"
      />

      <View className="flex-row justify-center mt-6">
        <Text className="text-white/50">New here? </Text>
        <Link href="/(auth)/sign-up">
          <Text className="text-brand-primary font-semibold">Create account</Text>
        </Link>
      </View>
    </ScrollView>
  )
}
```

**app/(app)/_layout.tsx** — Protected app layout with tab-like nav (simplified for Phase 1 — no bottom tab navigator yet, that's Phase 2):
```tsx
import { Stack, router } from 'expo-router'

export default function AppLayout() {
  return (
    <Stack
      screenOptions={{
        headerStyle: { backgroundColor: '#131318' },
        headerTintColor: '#ffffff',
        headerShadowVisible: false,
        contentStyle: { backgroundColor: '#0A0A0F' },
      }}
    />
  )
}
```

**app/(app)/profile.tsx** — Profile creation and edit screen (AUTH-05):
```tsx
import { View, Text, ScrollView, Alert, Image, TouchableOpacity } from 'react-native'
import { useForm, Controller } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import * as ImagePicker from 'expo-image-picker'
import { Stack } from 'expo-router'
import { Button } from '@/components/ui/Button'
import { Input } from '@/components/ui/Input'
import { useProfile, useUpdateProfile, useSignOut } from '@/features/auth/hooks'
import { supabase } from '@/lib/supabase'

const profileSchema = z.object({
  display_name: z.string().min(2).max(50),
})
type ProfileForm = z.infer<typeof profileSchema>

export default function ProfileScreen() {
  const { data: profile, isLoading } = useProfile()
  const { mutate: updateProfile, isPending: isSaving } = useUpdateProfile()
  const { mutate: signOut } = useSignOut()
  const { control, handleSubmit, formState: { errors } } = useForm<ProfileForm>({
    resolver: zodResolver(profileSchema),
    defaultValues: { display_name: profile?.display_name ?? '' },
  })

  const pickAvatar = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 0.8,
    })
    if (result.canceled || !result.assets[0]) return

    // Upload to Supabase Storage (avatars bucket — create this in Supabase dashboard as private)
    const uri = result.assets[0].uri
    const ext = uri.split('.').pop()
    const { data: { user } } = await supabase.auth.getUser()
    const fileName = `${user?.id}/avatar.${ext}`

    const response = await fetch(uri)
    const blob = await response.blob()
    const { error: uploadError } = await supabase.storage
      .from('avatars')
      .upload(fileName, blob, { upsert: true })

    if (uploadError) {
      Alert.alert('Upload Failed', uploadError.message)
      return
    }

    const { data: { publicUrl } } = supabase.storage
      .from('avatars')
      .getPublicUrl(fileName)

    updateProfile({ avatar_url: publicUrl })
  }

  const onSubmit = (data: ProfileForm) => {
    updateProfile(data, {
      onSuccess: () => Alert.alert('Saved', 'Profile updated'),
      onError: (e) => Alert.alert('Error', e.message),
    })
  }

  if (isLoading) return null

  return (
    <ScrollView className="flex-1 bg-dark-bg" contentContainerClassName="px-6 py-8">
      <Stack.Screen options={{ title: 'Profile' }} />

      {/* Avatar */}
      <TouchableOpacity onPress={pickAvatar} className="self-center mb-6">
        {profile?.avatar_url ? (
          <Image
            source={{ uri: profile.avatar_url }}
            className="w-24 h-24 rounded-full"
          />
        ) : (
          <View className="w-24 h-24 rounded-full bg-dark-surface border-2 border-brand-primary items-center justify-center">
            <Text className="text-brand-primary text-3xl font-bold">
              {profile?.display_name?.[0]?.toUpperCase() ?? '?'}
            </Text>
          </View>
        )}
        <Text className="text-brand-accent text-center mt-2 text-sm">Change photo</Text>
      </TouchableOpacity>

      {/* Display name */}
      <Controller
        control={control}
        name="display_name"
        render={({ field: { onChange, value } }) => (
          <Input
            label="Display name"
            placeholder="How should friends see you?"
            value={value}
            onChangeText={onChange}
            error={errors.display_name?.message}
          />
        )}
      />

      <Button
        title={isSaving ? 'Saving...' : 'Save profile'}
        onPress={handleSubmit(onSubmit)}
        disabled={isSaving}
        className="mt-6"
      />

      {/* AUTH-04: Sign out — accessible from profile screen */}
      <Button
        title="Sign out"
        variant="secondary"
        onPress={() => {
          signOut(undefined, {
            onError: (e) => Alert.alert('Sign Out Error', e.message),
          })
        }}
        className="mt-4"
      />
    </ScrollView>
  )
}
```
  </action>
  <verify>
    <automated>
      grep -l "useSession" app/_layout.tsx
      grep -l "Stack.Protected" app/_layout.tsx
      grep -l "supabase.auth.signInWithPassword" src/features/auth/hooks.ts
      grep -l "queryClient.clear" src/features/auth/hooks.ts
      grep -l "zodResolver" app/(auth)/sign-in.tsx app/(auth)/sign-up.tsx
    </automated>
  </verify>
  <done>
    - Auth types defined: Profile, SignInInput, SignUpInput, UpdateProfileInput
    - All six auth hooks implemented: useSession, useSignIn, useSignUp, useSignOut, useProfile, useUpdateProfile
    - app/_layout.tsx uses Stack.Protected guard={!!session} and guard={!session} for route groups
    - Sign-in and sign-up screens use react-hook-form + zod validation
    - Profile screen has avatar picker (expo-image-picker) and display name form
    - useSignOut calls queryClient.clear() on success (prevents stale data leakage between sessions)
    - useSession reads persisted session via supabase.auth.getSession() on mount
  </done>
</task>

<task type="auto">
  <name>Task 2: Groups feature hooks, types, and all group screens</name>
  <files>
    src/features/groups/types.ts
    src/features/groups/hooks.ts
    app/(app)/index.tsx
    app/(app)/groups/index.tsx
    app/(app)/groups/new.tsx
    app/(app)/groups/[id]/index.tsx
  </files>
  <action>
Create the groups feature slice and all group-related screens. The groups list query is automatically cached to MMKV via the PersistQueryClientProvider — OFFL-01 requires no additional code here beyond setting correct staleTime/gcTime (inherited from queryClient.ts defaults set in Plan 01-01).

**src/features/groups/types.ts**:
```typescript
export interface Group {
  id: string
  name: string
  base_currency: string
  created_by: string | null
  version: number
  created_at: string
  updated_at: string
}

export interface GroupMember {
  id: string
  group_id: string
  user_id: string | null    // null = named-only (non-app) member (GRUP-03)
  display_name: string
  role: 'admin' | 'member'
  joined_at: string
  created_at: string
}

export interface CreateGroupInput {
  name: string
  base_currency?: string
  named_members?: string[]  // Display names for non-app members (GRUP-03)
}

export interface AddNamedMemberInput {
  group_id: string
  display_name: string
}

export interface InviteMemberInput {
  group_id: string
  email: string
}
```

**src/features/groups/hooks.ts** — Full groups CRUD with RLS enforced at DB level:
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import type { Group, GroupMember, CreateGroupInput, AddNamedMemberInput, InviteMemberInput } from './types'

// Helper to get current user ID
async function getCurrentUserId(): Promise<string> {
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')
  return user.id
}

// GRUP-04: List all groups the current user belongs to
// Offline: React Query reads from MMKV cache when network is unavailable (OFFL-01)
export function useGroups() {
  return useQuery({
    queryKey: ['groups'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('group_members')
        .select(`
          group_id,
          role,
          groups (
            id,
            name,
            base_currency,
            created_by,
            version,
            created_at,
            updated_at
          )
        `)
        .eq('user_id', await getCurrentUserId())
      if (error) throw error
      return data?.map(row => row.groups as Group).filter(Boolean) ?? []
    },
    staleTime: 30_000, // Show stale groups, refetch in background after 30s
    // gcTime defaults to 24h from queryClient.ts — keeps cache alive across sessions (OFFL-01)
  })
}

// Get a single group with its members
export function useGroup(groupId: string) {
  return useQuery({
    queryKey: ['groups', groupId],
    queryFn: async () => {
      const { data: group, error: groupError } = await supabase
        .from('groups')
        .select('*')
        .eq('id', groupId)
        .single()
      if (groupError) throw groupError

      const { data: members, error: membersError } = await supabase
        .from('group_members')
        .select('*')
        .eq('group_id', groupId)
      if (membersError) throw membersError

      return { group: group as Group, members: members as GroupMember[] }
    },
    staleTime: 30_000,
  })
}

// GRUP-01: Create a group — creator is automatically added as admin in the same operation
export function useCreateGroup() {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: async ({ name, base_currency = 'USD', named_members = [] }: CreateGroupInput) => {
      const userId = await getCurrentUserId()

      // Fetch current user's display name for the group_members row
      const { data: profile } = await supabase
        .from('profiles')
        .select('display_name')
        .eq('id', userId)
        .single()

      // Create the group
      const { data: group, error: groupError } = await supabase
        .from('groups')
        .insert({ name, base_currency, created_by: userId })
        .select()
        .single()
      if (groupError) throw groupError

      // Add creator as admin (GRUP-01 requirement — creator must be in the group)
      const { error: memberError } = await supabase
        .from('group_members')
        .insert({
          group_id: group.id,
          user_id: userId,
          display_name: profile?.display_name ?? 'You',
          role: 'admin',
        })
      if (memberError) throw memberError

      // GRUP-03: Add named-only (non-app) members in the same operation
      if (named_members.length > 0) {
        const namedRows = named_members.map(displayName => ({
          group_id: group.id,
          user_id: null,           // NULL = named-only member
          display_name: displayName,
          role: 'member' as const,
        }))
        const { error: namedError } = await supabase
          .from('group_members')
          .insert(namedRows)
        if (namedError) throw namedError
      }

      return group as Group
    },
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: ['groups'] })
    },
  })
}

// GRUP-03: Add a named-only (non-app) member to an existing group
export function useAddNamedMember() {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: async ({ group_id, display_name }: AddNamedMemberInput) => {
      const { data, error } = await supabase
        .from('group_members')
        .insert({
          group_id,
          user_id: null,        // NULL = named-only
          display_name,
          role: 'member',
        })
        .select()
        .single()
      if (error) throw error
      return data as GroupMember
    },
    onSuccess: (_data, { group_id }) => {
      qc.invalidateQueries({ queryKey: ['groups', group_id] })
    },
  })
}

// GRUP-02: Invite a member by email
export function useInviteMember() {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: async ({ group_id, email }: InviteMemberInput) => {
      const userId = await getCurrentUserId()
      const { data, error } = await supabase
        .from('group_invites')
        .insert({
          group_id,
          invited_email: email.toLowerCase().trim(),
          invited_by: userId,
        })
        .select()
        .single()
      if (error) throw error
      return data
    },
    onSuccess: (_data, { group_id }) => {
      qc.invalidateQueries({ queryKey: ['groups', group_id] })
    },
  })
}

// GRUP-05: Leave a group
export function useLeaveGroup() {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: async (groupId: string) => {
      const userId = await getCurrentUserId()
      const { error } = await supabase
        .from('group_members')
        .delete()
        .eq('group_id', groupId)
        .eq('user_id', userId)
      if (error) throw error
    },
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: ['groups'] })
    },
  })
}
```

**app/(app)/index.tsx** — Dashboard with groups list (GRUP-04):
```tsx
import { View, Text, FlatList, TouchableOpacity, ActivityIndicator } from 'react-native'
import { Stack, router } from 'expo-router'
import { useGroups } from '@/features/groups/hooks'
import type { Group } from '@/features/groups/types'

function GroupCard({ group }: { group: Group }) {
  return (
    <TouchableOpacity
      onPress={() => router.push(`/(app)/groups/${group.id}`)}
      className="bg-dark-surface border border-dark-border rounded-2xl px-4 py-4 mb-3"
    >
      <Text className="text-white font-semibold text-base">{group.name}</Text>
      <Text className="text-white/40 text-sm mt-1">{group.base_currency}</Text>
    </TouchableOpacity>
  )
}

export default function DashboardScreen() {
  const { data: groups, isLoading, isError } = useGroups()

  return (
    <View className="flex-1 bg-dark-bg">
      <Stack.Screen
        options={{
          title: 'Nexus',
          headerRight: () => (
            <TouchableOpacity onPress={() => router.push('/(app)/profile')} className="mr-2">
              <Text className="text-brand-primary font-semibold">Profile</Text>
            </TouchableOpacity>
          ),
        }}
      />

      <FlatList
        data={groups ?? []}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => <GroupCard group={item} />}
        contentContainerClassName="px-4 pt-4 pb-8"
        ListHeaderComponent={
          <View className="mb-4">
            <Text className="text-white/50 text-sm uppercase tracking-wide mb-4">Your groups</Text>
          </View>
        }
        ListEmptyComponent={
          isLoading ? (
            <ActivityIndicator color="#6C63FF" />
          ) : (
            <View className="items-center py-12">
              <Text className="text-white/50 text-base">No groups yet</Text>
              <Text className="text-white/30 text-sm mt-1">Create one to get started</Text>
            </View>
          )
        }
      />

      {/* FAB to create group */}
      <TouchableOpacity
        onPress={() => router.push('/(app)/groups/new')}
        className="absolute bottom-8 right-6 bg-brand-primary w-14 h-14 rounded-full items-center justify-center"
        style={{ elevation: 8 }}
      >
        <Text className="text-white text-2xl font-light">+</Text>
      </TouchableOpacity>
    </View>
  )
}
```

**app/(app)/groups/new.tsx** — Create group screen (GRUP-01 + GRUP-03):
```tsx
import { View, Text, ScrollView, Alert, TextInput, TouchableOpacity } from 'react-native'
import { useState } from 'react'
import { useForm, Controller } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { Stack, router } from 'expo-router'
import { Button } from '@/components/ui/Button'
import { Input } from '@/components/ui/Input'
import { useCreateGroup } from '@/features/groups/hooks'

const createGroupSchema = z.object({
  name: z.string().min(1, 'Group name is required').max(100),
  base_currency: z.string().length(3, 'Use a 3-letter currency code').default('USD'),
})
type CreateGroupForm = z.infer<typeof createGroupSchema>

export default function NewGroupScreen() {
  const { mutate: createGroup, isPending } = useCreateGroup()
  const [namedMembers, setNamedMembers] = useState<string[]>([])
  const [newMemberName, setNewMemberName] = useState('')
  const { control, handleSubmit, formState: { errors } } = useForm<CreateGroupForm>({
    resolver: zodResolver(createGroupSchema),
    defaultValues: { base_currency: 'USD' },
  })

  const addNamedMember = () => {
    const name = newMemberName.trim()
    if (name.length < 2) return
    setNamedMembers(prev => [...prev, name])
    setNewMemberName('')
  }

  const onSubmit = (data: CreateGroupForm) => {
    createGroup(
      { ...data, named_members: namedMembers },
      {
        onSuccess: (group) => {
          router.replace(`/(app)/groups/${group.id}`)
        },
        onError: (e) => Alert.alert('Error', e.message),
      }
    )
  }

  return (
    <ScrollView
      className="flex-1 bg-dark-bg"
      contentContainerClassName="px-6 py-6"
      keyboardShouldPersistTaps="handled"
    >
      <Stack.Screen options={{ title: 'New Group' }} />

      <View className="gap-4">
        <Controller
          control={control}
          name="name"
          render={({ field: { onChange, value } }) => (
            <Input
              label="Group name"
              placeholder="Weekend trip, House expenses..."
              value={value}
              onChangeText={onChange}
              error={errors.name?.message}
            />
          )}
        />

        <Controller
          control={control}
          name="base_currency"
          render={({ field: { onChange, value } }) => (
            <Input
              label="Base currency"
              placeholder="USD"
              autoCapitalize="characters"
              maxLength={3}
              value={value}
              onChangeText={onChange}
              error={errors.base_currency?.message}
            />
          )}
        />

        {/* GRUP-03: Add named-only (non-app) members */}
        <View>
          <Text className="text-white/70 text-sm font-medium mb-2">
            Add friends who don't use the app (optional)
          </Text>
          <View className="flex-row gap-2">
            <TextInput
              className="flex-1 bg-dark-surface border border-dark-border rounded-xl px-4 py-3.5 text-white"
              placeholder="Their name"
              placeholderTextColor="#ffffff40"
              value={newMemberName}
              onChangeText={setNewMemberName}
              onSubmitEditing={addNamedMember}
            />
            <TouchableOpacity
              onPress={addNamedMember}
              className="bg-dark-surface border border-dark-border rounded-xl px-4 items-center justify-center"
            >
              <Text className="text-brand-accent font-semibold">Add</Text>
            </TouchableOpacity>
          </View>

          {namedMembers.map((name, idx) => (
            <View key={idx} className="flex-row items-center justify-between mt-2 bg-dark-surface rounded-xl px-4 py-3">
              <Text className="text-white">{name}</Text>
              <TouchableOpacity onPress={() => setNamedMembers(prev => prev.filter((_, i) => i !== idx))}>
                <Text className="text-brand-danger text-sm">Remove</Text>
              </TouchableOpacity>
            </View>
          ))}
        </View>
      </View>

      <Button
        title={isPending ? 'Creating...' : 'Create group'}
        onPress={handleSubmit(onSubmit)}
        disabled={isPending}
        className="mt-8"
      />
    </ScrollView>
  )
}
```

**app/(app)/groups/index.tsx** — Groups list screen (alternative navigation path):
```tsx
import { View, Text, FlatList, TouchableOpacity, ActivityIndicator } from 'react-native'
import { Stack, router } from 'expo-router'
import { useGroups } from '@/features/groups/hooks'

export default function GroupsListScreen() {
  const { data: groups, isLoading } = useGroups()

  return (
    <View className="flex-1 bg-dark-bg">
      <Stack.Screen options={{ title: 'Groups' }} />
      <FlatList
        data={groups ?? []}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <TouchableOpacity
            onPress={() => router.push(`/(app)/groups/${item.id}`)}
            className="bg-dark-surface border border-dark-border mx-4 mb-3 rounded-2xl px-4 py-4"
          >
            <Text className="text-white font-semibold text-base">{item.name}</Text>
            <Text className="text-white/40 text-sm mt-1">{item.base_currency}</Text>
          </TouchableOpacity>
        )}
        contentContainerClassName="pt-4 pb-8"
        ListEmptyComponent={
          isLoading ? (
            <ActivityIndicator color="#6C63FF" className="mt-12" />
          ) : (
            <View className="items-center py-12">
              <Text className="text-white/50">No groups yet</Text>
            </View>
          )
        }
      />
    </View>
  )
}
```

**app/(app)/groups/[id]/index.tsx** — Group detail screen with member list and leave option (GRUP-05):
```tsx
import { View, Text, FlatList, Alert, TouchableOpacity, ActivityIndicator } from 'react-native'
import { Stack, useLocalSearchParams, router } from 'expo-router'
import { Button } from '@/components/ui/Button'
import { useGroup, useLeaveGroup, useInviteMember } from '@/features/groups/hooks'
import type { GroupMember } from '@/features/groups/types'

function MemberRow({ member }: { member: GroupMember }) {
  const isNamedOnly = member.user_id === null
  return (
    <View className="flex-row items-center py-3 border-b border-dark-border">
      <View className="w-10 h-10 rounded-full bg-dark-surface border border-dark-border items-center justify-center mr-3">
        <Text className="text-white font-semibold">
          {member.display_name[0]?.toUpperCase()}
        </Text>
      </View>
      <View className="flex-1">
        <Text className="text-white font-medium">{member.display_name}</Text>
        {isNamedOnly && (
          <Text className="text-white/40 text-xs">Not on Nexus</Text>
        )}
      </View>
      {member.role === 'admin' && (
        <Text className="text-brand-accent text-xs font-medium">admin</Text>
      )}
    </View>
  )
}

export default function GroupDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>()
  const { data, isLoading } = useGroup(id)
  const { mutate: leaveGroup, isPending: isLeaving } = useLeaveGroup()
  const { mutate: inviteMember } = useInviteMember()

  const handleLeave = () => {
    // GRUP-05: Allow leaving even with outstanding balances (user decides)
    Alert.alert(
      'Leave group?',
      'You can rejoin if invited again. Outstanding balances will remain visible to other members.',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Leave',
          style: 'destructive',
          onPress: () => {
            leaveGroup(id, {
              onSuccess: () => router.back(),
              onError: (e) => Alert.alert('Error', e.message),
            })
          },
        },
      ]
    )
  }

  const handleInvite = () => {
    Alert.prompt(
      'Invite by email',
      'Enter the email address to send an invite',
      (email) => {
        if (!email) return
        inviteMember(
          { group_id: id, email },
          {
            onSuccess: () => Alert.alert('Invite sent', `Invite sent to ${email}`),
            onError: (e) => Alert.alert('Error', e.message),
          }
        )
      },
      'plain-text',
      '',
      'email-address'
    )
  }

  if (isLoading) {
    return (
      <View className="flex-1 bg-dark-bg items-center justify-center">
        <ActivityIndicator color="#6C63FF" />
      </View>
    )
  }

  return (
    <View className="flex-1 bg-dark-bg">
      <Stack.Screen options={{ title: data?.group.name ?? 'Group' }} />

      <FlatList
        data={data?.members ?? []}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => <MemberRow member={item} />}
        contentContainerClassName="px-4"
        ListHeaderComponent={
          <View className="mb-4 pt-4">
            <Text className="text-white/50 text-sm uppercase tracking-wide mb-1">Members</Text>
          </View>
        }
        ListFooterComponent={
          <View className="mt-8 gap-3">
            {/* GRUP-02: Invite by email */}
            <Button title="Invite by email" variant="secondary" onPress={handleInvite} />
            {/* GRUP-05: Leave group */}
            <Button
              title={isLeaving ? 'Leaving...' : 'Leave group'}
              variant="danger"
              onPress={handleLeave}
              disabled={isLeaving}
            />
          </View>
        }
      />
    </View>
  )
}
```
  </action>
  <verify>
    <automated>
      # Verify feature hook files exist with correct exports
      grep -l "useGroups" src/features/groups/hooks.ts app/(app)/index.tsx
      grep -l "useCreateGroup" src/features/groups/hooks.ts app/(app)/groups/new.tsx
      grep -l "useLeaveGroup" src/features/groups/hooks.ts app/(app)/groups/[id]/index.tsx
      grep -l "user_id.*null" src/features/groups/hooks.ts
      # Verify named-only member support (GRUP-03)
      grep "user_id: null" src/features/groups/hooks.ts
      # Verify all route files exist
      ls app/(app)/groups/new.tsx app/(app)/groups/index.tsx "app/(app)/groups/[id]/index.tsx"
    </automated>
  </verify>
  <done>
    - Groups types defined: Group, GroupMember, CreateGroupInput, AddNamedMemberInput, InviteMemberInput
    - All groups hooks implemented: useGroups, useGroup, useCreateGroup, useAddNamedMember, useInviteMember, useLeaveGroup
    - useGroups query key is ['groups'] — persisted to MMKV via PersistQueryClientProvider (OFFL-01)
    - useCreateGroup inserts named members with user_id: null (GRUP-03 requirement)
    - Group detail screen has both "Invite by email" (GRUP-02) and "Leave group" (GRUP-05) actions
    - All group screens navigate correctly via expo-router (useLocalSearchParams for dynamic [id] route)
    - Groups list shows stale cached data immediately on app launch before network fetch completes
  </done>
</task>

</tasks>

<verification>
Manual verification steps (end-to-end flows):

1. Sign up flow: Open app, tap "Create account", fill in name/email/password, submit. App navigates to dashboard. Groups list is empty.
2. Sign in flow: Sign out, return to sign-in, enter credentials, tap Sign in. Returns to dashboard.
3. Session persistence: Sign in, kill the app completely, reopen. User should be on the dashboard without re-authenticating (AUTH-03).
4. Profile edit: Navigate to Profile, change display name, tap Save. Name updates.
5. Create group: Tap + FAB, enter group name "Test Group", add named member "Charlie". Tap Create. Navigates to group detail showing two members (you + Charlie). Charlie shows "Not on Nexus" label.
6. Invite by email: Tap "Invite by email" in group detail. Enter an email. Alert confirms invite sent.
7. Offline cache (OFFL-01): Enable airplane mode, reopen app. Groups list should still show previously loaded groups from MMKV cache.
8. Leave group: Navigate to a group, tap "Leave group", confirm. Group disappears from list.
</verification>

<success_criteria>
- AUTH-01: Sign up with email + password creates an account (Supabase dashboard shows new user)
- AUTH-02: Sign in with correct credentials navigates to dashboard; wrong credentials show error
- AUTH-03: Killing and reopening the app lands on dashboard, not sign-in screen
- AUTH-04: Sign out from profile screen clears session and shows sign-in screen
- AUTH-05: Profile screen shows avatar + display name; editing saves to Supabase
- GRUP-01: Creating a group adds the creator as admin in group_members
- GRUP-02: Invite by email creates a row in group_invites table
- GRUP-03: Named-only members are inserted with user_id = NULL and display_name set
- GRUP-04: Dashboard shows all groups the user belongs to (via group_members JOIN groups RLS)
- GRUP-05: Leave group deletes the user's group_members row and removes group from list
- OFFL-01: Groups list visible with no network connectivity (stale MMKV cache served by React Query)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md` with:
- All hooks implemented and their signatures
- All screens created (with route paths)
- Auth storage adapter used (expo-sqlite localStorage)
- How OFFL-01 is satisfied (React Query gcTime + PersistQueryClientProvider)
- Any deviations from plan and why
- Manual verification results (which flows were tested)
</output>
