---
phase: 01-foundation
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260227000001_foundation.sql
  - supabase/seed.sql
  - .github/workflows/ci.yml
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04
  - AUTH-05
  - GRUP-01
  - GRUP-02
  - GRUP-03
  - GRUP-04
  - GRUP-05

must_haves:
  truths:
    - "All tables have RLS enabled — no authenticated user can read another user's group data"
    - "All monetary columns are INTEGER (cents) — no FLOAT, DECIMAL, or NUMERIC for money amounts"
    - "expenses table has fx_rate_at_creation, idempotency_key, and version columns — set in schema, can never be retroactively added without migration"
    - "group_members.user_id is nullable — named-only (non-app) members are representable in the schema"
    - "profiles table auto-creates on auth.users INSERT via PostgreSQL trigger"
    - "CI check fails if SUPABASE_SERVICE_ROLE_KEY appears in any tracked file"
    - "supabase db reset seeds two test users in overlapping groups — RLS tested by querying as User B for User A's data"
  artifacts:
    - path: "supabase/migrations/20260227000001_foundation.sql"
      provides: "All Phase 1 schema: profiles, groups, group_members, group_invites, expenses, expense_splits, settlements — with RLS on every table"
      min_lines: 200
    - path: "supabase/seed.sql"
      provides: "Test data: 2 users, 2 overlapping groups, RLS validation queries"
      contains: "test_user"
    - path: ".github/workflows/ci.yml"
      provides: "CI pipeline: lint, type-check, service_role key scan, supabase db reset + RLS test"
      contains: "service_role"
  key_links:
    - from: "supabase/migrations/20260227000001_foundation.sql"
      to: "auth.users"
      via: "on_auth_user_created trigger"
      pattern: "on_auth_user_created"
    - from: "group_members"
      to: "groups"
      via: "RLS policy using group_members as the access anchor"
      pattern: "SELECT group_id FROM public.group_members WHERE user_id = auth.uid"
    - from: ".github/workflows/ci.yml"
      to: "SUPABASE_SERVICE_ROLE_KEY"
      via: "grep scan of tracked files"
      pattern: "service_role"
---

<objective>
Create the hardened PostgreSQL schema via a single Supabase migration that encodes every Phase 1 data decision that cannot be changed retroactively: integer-cent storage, RLS on all tables, version columns for optimistic concurrency, fx_rate_at_creation snapshot column, idempotency keys, and the profiles auto-creation trigger. Add a seed file for RLS testing and a CI check that prevents the service_role key from being bundled into the mobile app.

Purpose: The six irrecoverable mistakes from PITFALLS.md (float currency, RLS omission, FX rate drift, offline conflict, service_role exposure, Expo Go) must be baked into the schema NOW. A migration added in Phase 2 to add `amount_cents` would require a full data migration of live data — unacceptable. This migration is the single source of truth for the database shape.

Output: `supabase/migrations/20260227000001_foundation.sql` applied to the Supabase project; `supabase/seed.sql` that validates RLS policies; CI workflow that rejects service_role key leakage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/research/PITFALLS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write and apply the foundation database migration</name>
  <files>
    supabase/migrations/20260227000001_foundation.sql
  </files>
  <action>
Install Supabase CLI if not present (`pnpm add -g supabase`) then initialize the Supabase project:
```bash
supabase init
supabase link --project-ref YOUR_PROJECT_REF
```

Create `supabase/migrations/20260227000001_foundation.sql` with the full schema below. Every section is mandatory — do not omit or abbreviate.

CRITICAL rules baked into this schema (from PITFALLS.md):
1. All monetary amounts are `INTEGER` (cents) — NEVER `FLOAT`, `DECIMAL`, or `NUMERIC` for money
2. `ALTER TABLE ... ENABLE ROW LEVEL SECURITY` immediately follows EVERY `CREATE TABLE`
3. `version INTEGER NOT NULL DEFAULT 1` on every mutable record (expenses, settlements, groups)
4. `fx_rate_at_creation NUMERIC(12,6) NOT NULL DEFAULT 1.0` on expenses — set at creation, NEVER updated
5. `idempotency_key UUID NOT NULL DEFAULT gen_random_uuid() UNIQUE` on expenses and settlements
6. `group_members.user_id` is nullable — NULL means named-only (non-app) member (GRUP-03)
7. `profiles` auto-creates via trigger on `auth.users` INSERT — cannot be skipped

```sql
-- =============================================================
-- NEXUS — FOUNDATION SCHEMA
-- Migration: 20260227000001_foundation.sql
-- Phase 1: All tables, RLS policies, and triggers
--
-- RULES (enforced here, cannot be changed retroactively):
-- 1. Monetary amounts stored as INTEGER cents (never FLOAT)
-- 2. RLS enabled on every table immediately after CREATE TABLE
-- 3. version column on all mutable records
-- 4. fx_rate_at_creation on expenses (historical snapshot)
-- 5. idempotency_key on expenses and settlements
-- =============================================================

-- ─────────────────────────────────────────────────────────────
-- PROFILES (extends auth.users — one row per registered user)
-- ─────────────────────────────────────────────────────────────
CREATE TABLE public.profiles (
  id            UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  display_name  TEXT,
  avatar_url    TEXT,
  push_token    TEXT,         -- Expo push token; updated on each app launch (Phase 3)
  created_at    TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at    TIMESTAMPTZ DEFAULT now() NOT NULL
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Users can read their own profile
CREATE POLICY "users_can_read_own_profile"
  ON public.profiles FOR SELECT
  USING (id = auth.uid());

-- Users can update their own profile
CREATE POLICY "users_can_update_own_profile"
  ON public.profiles FOR UPDATE
  USING (id = auth.uid())
  WITH CHECK (id = auth.uid());

-- Group members can read each other's profiles (needed to display names in group views)
CREATE POLICY "group_members_can_read_profiles"
  ON public.profiles FOR SELECT
  USING (
    id IN (
      SELECT gm.user_id
      FROM public.group_members gm
      WHERE gm.group_id IN (
        SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
      )
      AND gm.user_id IS NOT NULL
    )
  );

-- Auto-create profile on auth.users INSERT
-- SECURITY DEFINER required to write to public.profiles from auth schema trigger
CREATE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.profiles (id, display_name)
  VALUES (
    new.id,
    new.raw_user_meta_data ->> 'display_name'
  );
  RETURN new;
END;
$$;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- ─────────────────────────────────────────────────────────────
-- GROUPS
-- ─────────────────────────────────────────────────────────────
CREATE TABLE public.groups (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name          TEXT NOT NULL CHECK (char_length(name) >= 1 AND char_length(name) <= 100),
  base_currency TEXT NOT NULL DEFAULT 'USD',
  created_by    UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  version       INTEGER NOT NULL DEFAULT 1,
  created_at    TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at    TIMESTAMPTZ DEFAULT now() NOT NULL
);
ALTER TABLE public.groups ENABLE ROW LEVEL SECURITY;

-- Members can read groups they belong to
CREATE POLICY "members_can_read_groups"
  ON public.groups FOR SELECT
  USING (
    id IN (
      SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
    )
  );

-- Members can update groups they belong to (admin check enforced in app layer for now)
CREATE POLICY "members_can_update_groups"
  ON public.groups FOR UPDATE
  USING (
    id IN (
      SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
    )
  )
  WITH CHECK (
    id IN (
      SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
    )
  );

-- Any authenticated user can create a group (they auto-join as admin in the same operation)
CREATE POLICY "authenticated_can_create_groups"
  ON public.groups FOR INSERT
  WITH CHECK (auth.uid() IS NOT NULL);

-- ─────────────────────────────────────────────────────────────
-- GROUP MEMBERS
-- NULL user_id = named-only (non-app) member (GRUP-03)
-- ─────────────────────────────────────────────────────────────
CREATE TABLE public.group_members (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  group_id      UUID NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  user_id       UUID REFERENCES public.profiles(id) ON DELETE SET NULL,  -- NULL = named-only member
  display_name  TEXT NOT NULL,   -- For named-only: the name given; for real users: mirrors profile.display_name
  role          TEXT NOT NULL DEFAULT 'member' CHECK (role IN ('admin', 'member')),
  joined_at     TIMESTAMPTZ DEFAULT now() NOT NULL,
  created_at    TIMESTAMPTZ DEFAULT now() NOT NULL,
  CONSTRAINT unique_user_per_group UNIQUE (group_id, user_id)
);
ALTER TABLE public.group_members ENABLE ROW LEVEL SECURITY;

-- Members can see all members of groups they belong to
CREATE POLICY "members_can_read_group_members"
  ON public.group_members FOR SELECT
  USING (
    group_id IN (
      SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
    )
  );

-- Group admins can add new members; users can add themselves (on invite acceptance)
CREATE POLICY "admins_can_insert_members"
  ON public.group_members FOR INSERT
  WITH CHECK (
    -- Group admin adding someone
    group_id IN (
      SELECT group_id FROM public.group_members
      WHERE user_id = auth.uid() AND role = 'admin'
    )
    -- OR the user is adding themselves (accepting an invite)
    OR user_id = auth.uid()
  );

-- Users can remove themselves (leave group — GRUP-05)
CREATE POLICY "members_can_delete_own_membership"
  ON public.group_members FOR DELETE
  USING (user_id = auth.uid());

-- Admins can remove other members
CREATE POLICY "admins_can_delete_members"
  ON public.group_members FOR DELETE
  USING (
    group_id IN (
      SELECT group_id FROM public.group_members
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- ─────────────────────────────────────────────────────────────
-- GROUP INVITES (GRUP-02: invite by email)
-- ─────────────────────────────────────────────────────────────
CREATE TABLE public.group_invites (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  group_id        UUID NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  invited_email   TEXT NOT NULL,
  invited_by      UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  accepted_at     TIMESTAMPTZ,
  expires_at      TIMESTAMPTZ DEFAULT (now() + INTERVAL '7 days') NOT NULL,
  created_at      TIMESTAMPTZ DEFAULT now() NOT NULL,
  CONSTRAINT unique_pending_invite UNIQUE (group_id, invited_email)
);
ALTER TABLE public.group_invites ENABLE ROW LEVEL SECURITY;

-- Group members can see invites for their groups; invited users can see their own invites
CREATE POLICY "members_and_invitees_can_read_invites"
  ON public.group_invites FOR SELECT
  USING (
    group_id IN (
      SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
    )
    OR invited_email = (
      SELECT email FROM auth.users WHERE id = auth.uid()
    )
  );

-- Group members can create invites for their groups
CREATE POLICY "members_can_create_invites"
  ON public.group_invites FOR INSERT
  WITH CHECK (
    group_id IN (
      SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
    )
    AND invited_by = auth.uid()
  );

-- ─────────────────────────────────────────────────────────────
-- EXPENSES
-- Schema defined here in Phase 1; feature work in Phase 2.
-- Columns that CANNOT be added retroactively without data migration:
--   amount_cents (integer cents — never float)
--   fx_rate_at_creation (historical rate snapshot)
--   idempotency_key (prevents duplicate on retry)
--   version (optimistic concurrency for offline sync)
-- ─────────────────────────────────────────────────────────────
CREATE TABLE public.expenses (
  id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  group_id            UUID NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  created_by          UUID NOT NULL REFERENCES public.profiles(id),
  description         TEXT NOT NULL CHECK (char_length(description) >= 1),
  amount_cents        INTEGER NOT NULL CHECK (amount_cents > 0),   -- INTEGER cents only. NEVER float. $47.99 = 4799
  currency            TEXT NOT NULL DEFAULT 'USD',
  base_currency       TEXT NOT NULL,                              -- Group's base currency at time of creation
  fx_rate_at_creation NUMERIC(12, 6) NOT NULL DEFAULT 1.000000,  -- Historical rate snapshot. NEVER updated after insert.
  amount_base_cents   INTEGER NOT NULL,                           -- amount_cents * fx_rate_at_creation, computed at insert
  split_type          TEXT NOT NULL DEFAULT 'equal'
                        CHECK (split_type IN ('equal', 'exact', 'percentage', 'shares')),
  payer_id            UUID REFERENCES public.group_members(id),
  expense_date        DATE NOT NULL DEFAULT CURRENT_DATE,
  category            TEXT,                                       -- Optional category tag
  idempotency_key     UUID NOT NULL DEFAULT gen_random_uuid() UNIQUE,  -- Prevents duplicate expense on network retry
  version             INTEGER NOT NULL DEFAULT 1,
  deleted_at          TIMESTAMPTZ,                               -- Soft delete (audit trail)
  created_at          TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at          TIMESTAMPTZ DEFAULT now() NOT NULL
);
ALTER TABLE public.expenses ENABLE ROW LEVEL SECURITY;

CREATE POLICY "members_can_read_expenses"
  ON public.expenses FOR SELECT
  USING (
    group_id IN (
      SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "members_can_insert_expenses"
  ON public.expenses FOR INSERT
  WITH CHECK (
    group_id IN (
      SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
    )
    AND created_by = auth.uid()
  );

-- Only the creator can update their own expenses
CREATE POLICY "creators_can_update_expenses"
  ON public.expenses FOR UPDATE
  USING (created_by = auth.uid())
  WITH CHECK (created_by = auth.uid());

-- ─────────────────────────────────────────────────────────────
-- EXPENSE SPLITS (schema-only in Phase 1)
-- ─────────────────────────────────────────────────────────────
CREATE TABLE public.expense_splits (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  expense_id    UUID NOT NULL REFERENCES public.expenses(id) ON DELETE CASCADE,
  member_id     UUID NOT NULL REFERENCES public.group_members(id),
  amount_cents  INTEGER NOT NULL CHECK (amount_cents >= 0),  -- Integer cents only
  created_at    TIMESTAMPTZ DEFAULT now() NOT NULL
);
ALTER TABLE public.expense_splits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "members_can_read_splits"
  ON public.expense_splits FOR SELECT
  USING (
    expense_id IN (
      SELECT e.id FROM public.expenses e
      WHERE e.group_id IN (
        SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
      )
    )
  );

CREATE POLICY "members_can_insert_splits"
  ON public.expense_splits FOR INSERT
  WITH CHECK (
    expense_id IN (
      SELECT e.id FROM public.expenses e
      WHERE e.group_id IN (
        SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
      )
    )
  );

-- ─────────────────────────────────────────────────────────────
-- SETTLEMENTS (schema-only in Phase 1)
-- ─────────────────────────────────────────────────────────────
CREATE TABLE public.settlements (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  group_id        UUID NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  payer_id        UUID NOT NULL REFERENCES public.group_members(id),
  payee_id        UUID NOT NULL REFERENCES public.group_members(id),
  amount_cents    INTEGER NOT NULL CHECK (amount_cents > 0),  -- Integer cents only
  currency        TEXT NOT NULL,
  idempotency_key UUID NOT NULL DEFAULT gen_random_uuid() UNIQUE,
  version         INTEGER NOT NULL DEFAULT 1,
  settled_at      TIMESTAMPTZ DEFAULT now() NOT NULL,
  created_at      TIMESTAMPTZ DEFAULT now() NOT NULL,
  CONSTRAINT different_payer_payee CHECK (payer_id <> payee_id)
);
ALTER TABLE public.settlements ENABLE ROW LEVEL SECURITY;

CREATE POLICY "members_can_read_settlements"
  ON public.settlements FOR SELECT
  USING (
    group_id IN (
      SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "members_can_insert_settlements"
  ON public.settlements FOR INSERT
  WITH CHECK (
    group_id IN (
      SELECT group_id FROM public.group_members WHERE user_id = auth.uid()
    )
  );

-- ─────────────────────────────────────────────────────────────
-- INDEXES (performance — added here to avoid ALTER TABLE later)
-- ─────────────────────────────────────────────────────────────
CREATE INDEX idx_group_members_user_id ON public.group_members(user_id);
CREATE INDEX idx_group_members_group_id ON public.group_members(group_id);
CREATE INDEX idx_expenses_group_id ON public.expenses(group_id);
CREATE INDEX idx_expenses_created_by ON public.expenses(created_by);
CREATE INDEX idx_expenses_expense_date ON public.expenses(expense_date DESC);
CREATE INDEX idx_expense_splits_expense_id ON public.expense_splits(expense_id);
CREATE INDEX idx_settlements_group_id ON public.settlements(group_id);
CREATE INDEX idx_group_invites_invited_email ON public.group_invites(invited_email);
```

After writing the file, apply the migration to the Supabase project:
```bash
supabase db push
```

Verify the migration applied successfully:
```bash
supabase db diff  # should show no pending changes after push
```
  </action>
  <verify>
    <automated>
      # Verify migration file exists and has key patterns
      grep -c "ENABLE ROW LEVEL SECURITY" supabase/migrations/20260227000001_foundation.sql
      # Expected: 7 (one per table: profiles, groups, group_members, group_invites, expenses, expense_splits, settlements)
      grep "amount_cents.*INTEGER" supabase/migrations/20260227000001_foundation.sql
      # Expected: lines showing INTEGER type for amount_cents columns (not FLOAT or NUMERIC)
      grep "fx_rate_at_creation" supabase/migrations/20260227000001_foundation.sql
      # Expected: the column definition with NUMERIC(12,6)
      grep "idempotency_key" supabase/migrations/20260227000001_foundation.sql
      # Expected: two occurrences (expenses + settlements)
    </automated>
  </verify>
  <done>
    - `supabase/migrations/20260227000001_foundation.sql` exists with all 7 tables
    - Every table has `ENABLE ROW LEVEL SECURITY` on the line immediately after `CREATE TABLE`
    - All monetary columns are `INTEGER` (search for FLOAT or DECIMAL returns 0 matches)
    - `expenses` table has `fx_rate_at_creation NUMERIC(12,6)`, `idempotency_key UUID UNIQUE`, and `version INTEGER`
    - `group_members.user_id` is nullable (no `NOT NULL` constraint)
    - `profiles` trigger `on_auth_user_created` is present
    - `supabase db push` completed without errors
    - 7 tables visible in Supabase dashboard under the `public` schema
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RLS seed file and CI service_role key guard</name>
  <files>
    supabase/seed.sql
    .github/workflows/ci.yml
  </files>
  <action>
**supabase/seed.sql** — Test data for RLS validation. This runs after `supabase db reset` in CI. The RLS check at the bottom is the critical test — if RLS is correctly configured, User B cannot read User A's groups.

```sql
-- supabase/seed.sql
-- RLS validation seed: two users in overlapping groups
-- Run with: supabase db reset (applies migration then seed)

-- NOTE: In Supabase local dev, auth.users cannot be directly INSERTed from SQL.
-- Use the service role API or Supabase auth.users helper for test user creation.
-- These UUIDs are fixed for reproducible testing.

-- Insert test profiles directly (assumes auth.users already has these IDs via auth API or test setup)
INSERT INTO public.profiles (id, display_name) VALUES
  ('00000000-0000-0000-0000-000000000001', 'Alice Test'),
  ('00000000-0000-0000-0000-000000000002', 'Bob Test')
ON CONFLICT (id) DO NOTHING;

-- Alice creates Group A (she should be admin)
INSERT INTO public.groups (id, name, base_currency, created_by) VALUES
  ('10000000-0000-0000-0000-000000000001', 'Alice Group A', 'USD', '00000000-0000-0000-0000-000000000001');

-- Bob creates Group B (he should be admin)
INSERT INTO public.groups (id, name, base_currency, created_by) VALUES
  ('10000000-0000-0000-0000-000000000002', 'Bob Group B', 'USD', '00000000-0000-0000-0000-000000000002');

-- Alice is admin of Group A, Bob is member of Group A (shared group)
INSERT INTO public.group_members (group_id, user_id, display_name, role) VALUES
  ('10000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000001', 'Alice Test', 'admin'),
  ('10000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000002', 'Bob Test', 'member');

-- Bob is admin of Group B (Alice has NO access to Group B)
INSERT INTO public.group_members (group_id, user_id, display_name, role) VALUES
  ('10000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-000000000002', 'Bob Test', 'admin');

-- Named-only member in Group A (demonstrates GRUP-03)
INSERT INTO public.group_members (group_id, user_id, display_name, role) VALUES
  ('10000000-0000-0000-0000-000000000001', NULL, 'Charlie (non-app)', 'member');

-- ─────────────────────────────────────────────────────────────
-- RLS VALIDATION QUERIES
-- Run these manually in Supabase SQL editor as authenticated User B
-- to verify User B CANNOT read User A's exclusive group (Group B's Group A view)
--
-- Expected results when authenticated as User B (bob):
--   SELECT * FROM groups WHERE id = '10000000-0000-0000-0000-000000000001' → 1 row (Bob is member)
--   SELECT * FROM groups WHERE id = '10000000-0000-0000-0000-000000000002' → 1 row (Bob is admin)
--
-- Expected results when authenticated as User A (alice):
--   SELECT * FROM groups WHERE id = '10000000-0000-0000-0000-000000000001' → 1 row (Alice is admin)
--   SELECT * FROM groups WHERE id = '10000000-0000-0000-0000-000000000002' → 0 rows (Alice NOT a member - RLS blocks)
-- ─────────────────────────────────────────────────────────────
```

**CI guard — .github/workflows/ci.yml** — Blocks the service_role key from appearing in any tracked file. Runs on every push and PR.

Create the `.github/workflows/` directory and write this file:

```yaml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  lint-and-typecheck:
    name: Lint and Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: 9

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Lint
        run: pnpm eslint . --ext .ts,.tsx

      - name: Type check
        run: pnpm tsc --noEmit

  security-scan:
    name: Security Scan — No Service Role Key in Bundle
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Scan for service_role key leakage
        run: |
          echo "Scanning for SUPABASE_SERVICE_ROLE_KEY in tracked files..."
          # Fail if service_role key appears in any JS/TS/JSON/config file
          # The key format is a long JWT starting with eyJ (base64-encoded)
          # We scan for the variable name, not the actual key value
          if grep -r "SERVICE_ROLE_KEY\|service_role_key\|serviceRoleKey" \
               --include="*.ts" \
               --include="*.tsx" \
               --include="*.js" \
               --include="*.jsx" \
               --include="*.json" \
               --include="app.config.*" \
               --include="eas.json" \
               --exclude-dir=".git" \
               --exclude-dir="node_modules" \
               --exclude-dir="supabase" \
               . ; then
            echo ""
            echo "ERROR: SUPABASE_SERVICE_ROLE_KEY reference found in client-side files!"
            echo "The service role key must ONLY exist in:"
            echo "  - Supabase Vault (for Edge Functions)"
            echo "  - CI/CD secrets (for migration scripts)"
            echo "  - Server-side code only"
            echo ""
            echo "The mobile app must use ONLY EXPO_PUBLIC_SUPABASE_ANON_KEY"
            exit 1
          fi
          echo "OK: No service role key references found in client files."

      - name: Verify Tailwind v3 pin
        run: |
          # NativeWind 4.x requires Tailwind v3 — v4 silently breaks all styles
          TAILWIND_VERSION=$(node -e "console.log(require('./node_modules/tailwindcss/package.json').version)" 2>/dev/null || echo "NOT_INSTALLED")
          echo "Installed tailwindcss version: $TAILWIND_VERSION"
          if [[ "$TAILWIND_VERSION" == 4.* ]]; then
            echo "ERROR: tailwindcss v4 is installed. NativeWind 4.x requires tailwindcss ^3.4.x"
            echo "Fix: pin to '^3.4.17' in package.json"
            exit 1
          fi
          echo "OK: tailwindcss is v3.x as required."

  schema-test:
    name: Schema and RLS Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Start Supabase local
        run: supabase start

      - name: Apply migrations and seed
        run: supabase db reset

      - name: Verify RLS — User A cannot read User B's exclusive group
        run: |
          # Connect as service role to verify the seed data exists
          supabase db query "SELECT count(*) FROM public.groups;" --local
          echo "Schema and seed applied successfully."
          echo "Manual RLS verification: sign in as Alice in Supabase Studio and verify"
          echo "  SELECT * FROM groups WHERE id = '10000000-0000-0000-0000-000000000002'"
          echo "  returns 0 rows (Alice is not a member of Bob's exclusive group)."
```

After creating both files, stage and verify:
```bash
# Ensure the migration count is correct
supabase migration list

# Verify the seed file exists
ls supabase/seed.sql

# Run the security scan locally as a sanity check
grep -r "SERVICE_ROLE_KEY\|service_role_key" --include="*.ts" --include="*.tsx" --include="*.json" app/ src/ 2>/dev/null
# Expected: no matches
```
  </action>
  <verify>
    <automated>
      # Verify RLS rule count (7 tables must each have ENABLE ROW LEVEL SECURITY)
      grep -c "ENABLE ROW LEVEL SECURITY" supabase/migrations/20260227000001_foundation.sql
      # Verify no FLOAT/DECIMAL/NUMERIC used for money amounts
      grep -E "FLOAT|DOUBLE PRECISION|DECIMAL\s|DECIMAL\(" supabase/migrations/20260227000001_foundation.sql
      # Expected: 0 lines (money stored as INTEGER only)
      # Verify service_role key guard file exists
      ls .github/workflows/ci.yml
      grep "SERVICE_ROLE_KEY" .github/workflows/ci.yml
    </automated>
  </verify>
  <done>
    - `supabase/seed.sql` creates 2 test users, 2 groups (1 shared, 1 exclusive), and 1 named-only member
    - `.github/workflows/ci.yml` scans for service_role key references and fails the CI build if found
    - CI also validates that tailwindcss is pinned to v3 (not v4)
    - CI runs `supabase db reset` to apply migrations and seed for schema testing
    - The security scan passes locally (0 service_role matches in app/ and src/)
    - All 7 tables visible in Supabase dashboard with RLS enabled (confirmed via Supabase Studio or `supabase db query`)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Count RLS policies in migration: `grep -c "ENABLE ROW LEVEL SECURITY" supabase/migrations/20260227000001_foundation.sql` — must return 7
2. Verify no float money: `grep -E "FLOAT|DECIMAL\s|DECIMAL\(" supabase/migrations/20260227000001_foundation.sql` — must return 0 lines
3. Verify idempotency keys: `grep -c "idempotency_key" supabase/migrations/20260227000001_foundation.sql` — must return at least 2 (expenses + settlements)
4. Verify fx_rate_at_creation: `grep "fx_rate_at_creation" supabase/migrations/20260227000001_foundation.sql` — must show NUMERIC(12,6) type
5. Verify trigger exists: `grep "on_auth_user_created" supabase/migrations/20260227000001_foundation.sql` — must return the trigger definition
6. In Supabase dashboard, verify all 7 tables in the `public` schema have the RLS shield icon enabled
7. CI workflow file exists and contains both the service_role key scan and the tailwindcss version check
</verification>

<success_criteria>
- All 7 tables (profiles, groups, group_members, group_invites, expenses, expense_splits, settlements) exist in Supabase with RLS enabled
- `expenses.amount_cents` is `INTEGER` — confirmed by table schema in Supabase dashboard
- `expenses.fx_rate_at_creation` is `NUMERIC(12,6)` with DEFAULT 1.0 — set-and-never-update contract documented in SQL comment
- `group_members.user_id` is nullable — NULL insertable (required for GRUP-03 named-only members)
- `supabase db push` completed with no errors
- CI workflow rejects any file containing `SERVICE_ROLE_KEY` in app/ or src/ directories
- CI workflow fails the build if tailwindcss v4 is detected in node_modules
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` with:
- Migration filename and what tables it created
- RLS policy count per table
- List of hardening decisions encoded (integer cents, fx_rate snapshot, idempotency_key, version column, nullable user_id)
- Result of `supabase db push` (success/error)
- CI workflow path and what it guards
</output>
